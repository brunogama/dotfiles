#!/bin/bash

# CredMatch - Secure Credential Management with Git (like Fastlane Match)
# Usage: ./credmatch <command> [options]

DEFAULT_STORE_DIR=".credmatch-store"
CREDENTIALS_FILE="credentials.enc"
CURRENT_DIR_MODE=false

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to display usage
usage() {
    echo "CredMatch - Secure Credential Management"
    echo ""
    echo "Usage: $0 <command> [options]"
    echo ""
    echo "Commands:"
    echo "  init <git_repo_url>                 Initialize credential store with git repository"
    echo "  init-here                           Use current directory as credential store"
    echo "  store <master_password> <key> <value>  Store a credential"
    echo "  fetch <master_password> <key>       Fetch a specific credential"
    echo "  list <master_password>              List all stored credentials"
    echo "  sync                                Sync with remote repository"
    echo "  status                              Show repository status"
    echo ""
    echo "Examples:"
    echo "  $0 init git@github.com:user/credentials.git"
    echo "  $0 init-here"
    echo "  $0 store mypassword API_KEY \"abc123\""
    echo "  $0 fetch mypassword API_KEY"
    echo "  $0 list mypassword"
    echo "  $0 sync"
    exit 1
}

# Check dependencies
check_dependencies() {
    if ! command -v git &> /dev/null; then
        echo -e "${RED}Error: Git is not installed or not in PATH${NC}"
        exit 1
    fi
    
    if ! command -v openssl &> /dev/null; then
        echo -e "${RED}Error: OpenSSL is not installed or not in PATH${NC}"
        exit 1
    fi
}

# Function to get store directory
get_store_dir() {
    if [ "$CURRENT_DIR_MODE" = true ]; then
        echo "."
    else
        echo "$DEFAULT_STORE_DIR"
    fi
}

# Function to check if store is initialized
check_store_initialized() {
    local store_dir=$(get_store_dir)
    
    if [ "$CURRENT_DIR_MODE" = true ]; then
        # For current directory mode, just check if it's a git repo
        if [ ! -d ".git" ]; then
            echo -e "${RED}Error: Current directory is not a git repository${NC}"
            echo "Run 'git init' first or use '$0 init <git_repo_url>' instead"
            exit 1
        fi
    else
        # For separate directory mode, check if .credmatch-store exists
        if [ ! -d "$store_dir" ]; then
            echo -e "${RED}Error: Credential store not initialized${NC}"
            echo "Run '$0 init <git_repo_url>' or '$0 init-here' first"
            exit 1
        fi
    fi
}

# Function to encrypt text
encrypt_text() {
    local password="$1"
    local text="$2"
    echo -n "$text" | openssl enc -aes-256-cbc -pbkdf2 -pass pass:"$password" 2>/dev/null | base64
}

# Function to decrypt text
decrypt_text() {
    local password="$1"
    local encrypted_text="$2"
    echo "$encrypted_text" | base64 -d | openssl enc -aes-256-cbc -d -pbkdf2 -pass pass:"$password" 2>/dev/null
}

# Function to initialize credential store
cmd_init() {
    local git_repo_url="$1"
    
    if [ -z "$git_repo_url" ]; then
        echo -e "${RED}Error: Git repository URL is required${NC}"
        echo "Usage: $0 init <git_repo_url>"
        exit 1
    fi
    
    if [ -d "$DEFAULT_STORE_DIR" ]; then
        echo -e "${YELLOW}Warning: Credential store already exists at $DEFAULT_STORE_DIR${NC}"
        read -p "Do you want to remove it and start fresh? (y/N): " confirm
        if [[ $confirm =~ ^[Yy]$ ]]; then
            rm -rf "$DEFAULT_STORE_DIR"
        else
            exit 1
        fi
    fi
    
    echo -e "${BLUE}Initializing credential store...${NC}"
    
    # Clone the repository
    if git clone "$git_repo_url" "$DEFAULT_STORE_DIR" 2>/dev/null; then
        echo -e "${GREEN}✓ Successfully cloned repository${NC}"
    else
        # If clone fails, create new repo
        echo -e "${YELLOW}Repository doesn't exist or is empty. Creating new repository...${NC}"
        mkdir -p "$DEFAULT_STORE_DIR"
        cd "$DEFAULT_STORE_DIR"
        git init
        git remote add origin "$git_repo_url"
        
        # Create initial empty credentials file
        echo "# CredMatch Encrypted Credentials Store" > README.md
        git add README.md
        git commit -m "Initial commit - CredMatch setup"
        
        # Try to push (might fail if repo doesn't exist on remote)
        git push -u origin main 2>/dev/null || git push -u origin master 2>/dev/null || true
        cd ..
        echo -e "${GREEN}✓ Created new repository${NC}"
    fi
    
    echo -e "${GREEN}✓ Credential store initialized at $DEFAULT_STORE_DIR${NC}"
    echo -e "${BLUE}You can now store credentials using: $0 store <password> <key> <value>${NC}"
}

# Function to initialize credential store in current directory
cmd_init_here() {
    if [ ! -d ".git" ]; then
        echo -e "${RED}Error: Current directory is not a git repository${NC}"
        echo "Please run 'git init' first or use '$0 init <git_repo_url>' instead"
        exit 1
    fi
    
    CURRENT_DIR_MODE=true
    echo -e "${BLUE}Initializing credential store in current directory...${NC}"
    echo -e "${GREEN}✓ Using current directory as credential store${NC}"
    echo -e "${BLUE}You can now store credentials using: $0 store <password> <key> <value>${NC}"
}

# Function to store a credential
cmd_store() {
    local master_password="$1"
    local key="$2"
    local value="$3"
    
    if [ -z "$master_password" ] || [ -z "$key" ] || [ -z "$value" ]; then
        echo -e "${RED}Error: Password, key, and value are required${NC}"
        echo "Usage: $0 store <master_password> <key> <value>"
        exit 1
    fi
    
    check_store_initialized
    
    local store_dir=$(get_store_dir)
    cd "$store_dir"
    
    # Pull latest changes
    git pull origin main 2>/dev/null || git pull origin master 2>/dev/null || true
    
    # Read existing credentials if file exists
    local credentials=""
    if [ -f "$CREDENTIALS_FILE" ]; then
        credentials=$(decrypt_text "$master_password" "$(cat "$CREDENTIALS_FILE")")
        if [ $? -ne 0 ]; then
            echo -e "${RED}Error: Failed to decrypt existing credentials. Check your master password.${NC}"
            exit 1
        fi
    fi
    
    # Remove existing key if it exists and add new one
    credentials=$(echo "$credentials" | grep -v "^$key=" | grep -v "^$")
    if [ ! -z "$credentials" ]; then
        credentials="$credentials"$'\n'"$key=$value"
    else
        credentials="$key=$value"
    fi
    
    # Encrypt and save
    encrypted=$(encrypt_text "$master_password" "$credentials")
    if [ $? -ne 0 ]; then
        echo -e "${RED}Error: Failed to encrypt credentials${NC}"
        exit 1
    fi
    
    echo "$encrypted" > "$CREDENTIALS_FILE"
    
    # Commit and push
    git add "$CREDENTIALS_FILE"
    git commit -m "Update credential: $key" --no-verify 2>/dev/null || git commit -m "Update credential: $key" 2>/dev/null
    git push origin main 2>/dev/null || git push origin master 2>/dev/null || true
    
    if [ "$CURRENT_DIR_MODE" != true ]; then
        cd ..
    fi
    echo -e "${GREEN}✓ Credential '$key' stored successfully${NC}"
}

# Function to fetch a specific credential
cmd_fetch() {
    local master_password="$1"
    local key="$2"
    
    if [ -z "$master_password" ] || [ -z "$key" ]; then
        echo -e "${RED}Error: Password and key are required${NC}"
        echo "Usage: $0 fetch <master_password> <key>"
        exit 1
    fi
    
    check_store_initialized
    
    local store_dir=$(get_store_dir)
    cd "$store_dir"
    
    # Pull latest changes
    git pull origin main 2>/dev/null || git pull origin master 2>/dev/null || true
    
    if [ ! -f "$CREDENTIALS_FILE" ]; then
        echo -e "${RED}Error: No credentials file found${NC}"
        exit 1
    fi
    
    # Decrypt and find key
    local credentials=$(decrypt_text "$master_password" "$(cat "$CREDENTIALS_FILE")")
    if [ $? -ne 0 ]; then
        echo -e "${RED}Error: Failed to decrypt credentials. Check your master password.${NC}"
        exit 1
    fi
    
    local value=$(echo "$credentials" | grep "^$key=" | cut -d'=' -f2-)
    
    if [ "$CURRENT_DIR_MODE" != true ]; then
        cd ..
    fi
    
    if [ ! -z "$value" ]; then
        echo "$value"
    else
        echo -e "${RED}Error: Credential '$key' not found${NC}"
        exit 1
    fi
}

# Function to list all credentials
cmd_list() {
    local master_password="$1"
    
    if [ -z "$master_password" ]; then
        echo -e "${RED}Error: Master password is required${NC}"
        echo "Usage: $0 list <master_password>"
        exit 1
    fi
    
    check_store_initialized
    
    local store_dir=$(get_store_dir)
    cd "$store_dir"
    
    # Pull latest changes
    git pull origin main 2>/dev/null || git pull origin master 2>/dev/null || true
    
    if [ ! -f "$CREDENTIALS_FILE" ]; then
        echo -e "${YELLOW}No credentials stored yet${NC}"
        exit 0
    fi
    
    # Decrypt and display
    local credentials=$(decrypt_text "$master_password" "$(cat "$CREDENTIALS_FILE")")
    if [ $? -ne 0 ]; then
        echo -e "${RED}Error: Failed to decrypt credentials. Check your master password.${NC}"
        exit 1
    fi
    
    if [ "$CURRENT_DIR_MODE" != true ]; then
        cd ..
    fi
    
    if [ ! -z "$credentials" ]; then
        echo -e "${GREEN}Stored Credentials:${NC}"
        echo "$credentials" | while IFS='=' read -r key value; do
            if [ ! -z "$key" ]; then
                echo -e "${BLUE}$key${NC}=$value"
            fi
        done
    else
        echo -e "${YELLOW}No credentials found${NC}"
    fi
}

# Function to sync with remote
cmd_sync() {
    check_store_initialized
    
    local store_dir=$(get_store_dir)
    cd "$store_dir"
    echo -e "${BLUE}Syncing with remote repository...${NC}"
    
    git pull origin main 2>/dev/null || git pull origin master 2>/dev/null
    
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}✓ Successfully synced with remote${NC}"
    else
        echo -e "${YELLOW}Warning: Sync may have failed or no changes to pull${NC}"
    fi
    
    if [ "$CURRENT_DIR_MODE" != true ]; then
        cd ..
    fi
}

# Function to show status
cmd_status() {
    check_store_initialized
    
    local store_dir=$(get_store_dir)
    cd "$store_dir"
    echo -e "${BLUE}Repository Status:${NC}"
    echo ""
    
    # Show remote
    echo -e "${GREEN}Remote:${NC}"
    git remote -v
    echo ""
    
    # Show status
    echo -e "${GREEN}Git Status:${NC}"
    git status --short
    
    # Show last commit
    echo ""
    echo -e "${GREEN}Last Commit:${NC}"
    git log --oneline -1
    
    if [ "$CURRENT_DIR_MODE" != true ]; then
        cd ..
    fi
}

# Detect if we should use current directory mode
detect_mode() {
    # Check if we're in a directory that looks like a credential store
    if [ -f "$CREDENTIALS_FILE" ] || [ -f ".git/config" ]; then
        # Check if .credmatch-store exists
        if [ ! -d "$DEFAULT_STORE_DIR" ]; then
            CURRENT_DIR_MODE=true
        fi
    fi
}

# Main script
check_dependencies

if [ $# -eq 0 ]; then
    usage
fi

command="$1"
shift

# Detect mode before processing commands
detect_mode

case "$command" in
    "init")
        cmd_init "$@"
        ;;
    "init-here")
        cmd_init_here "$@"
        ;;
    "store")
        cmd_store "$@"
        ;;
    "fetch")
        cmd_fetch "$@"
        ;;
    "list")
        cmd_list "$@"
        ;;
    "sync")
        cmd_sync "$@"
        ;;
    "status")
        cmd_status "$@"
        ;;
    *)
        echo -e "${RED}Error: Unknown command '$command'${NC}"
        echo "Did you mean 'init' instead of '--init'?"
        usage
        ;;
esac
