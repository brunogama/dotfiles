#!/usr/bin/env bash

# macOS Preferences Management Script
# Dumps, stores, and restores macOS system preferences and defaults

set -euo pipefail

# Configuration
readonly SCRIPT_NAME="$(basename "$0")"
readonly PREFS_DIR="$HOME/.config/macos-preferences"
readonly BACKUP_DIR="$HOME/.macos-preferences-backups"
readonly CURRENT_DUMP="$PREFS_DIR/current-preferences.plist"
readonly DOMAINS_FILE="$PREFS_DIR/domains.txt"
readonly SYSTEM_PREFS="$PREFS_DIR/system-preferences.sh"
readonly LOG_FILE="$PREFS_DIR/logs/$(date +%Y%m%d_%H%M%S).log"

# Colors
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[0;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m'

# Ensure directories exist
mkdir -p "$PREFS_DIR/logs" "$BACKUP_DIR"

# Logging function
log() {
    local level="$1"
    shift
    local message="$*"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$timestamp] [$level] $message" >> "$LOG_FILE"
    
    case "$level" in
        "ERROR") echo -e "${RED}[ERROR]${NC} $message" >&2 ;;
        "WARN")  echo -e "${YELLOW}[WARN]${NC} $message" ;;
        "INFO")  echo -e "${GREEN}[INFO]${NC} $message" ;;
        "DEBUG") [[ "${DEBUG:-}" == "1" ]] && echo -e "${BLUE}[DEBUG]${NC} $message" ;;
    esac
}

# Help function
show_help() {
    cat << 'HELP_EOF'
macOS Preferences Management

USAGE:
    macos-prefs <command> [options]

COMMANDS:
    dump                 Export current macOS preferences
    restore              Import and apply stored preferences
    diff                 Show differences between stored and current
    backup               Create timestamped backup of current preferences
    list                 List available preference domains
    domains              Update list of preference domains to track
    help                 Show this help message

OPTIONS:
    --dry-run           Show what would be done without making changes
    --force             Apply changes without confirmation
    --quiet, -q         Suppress output except errors
    --verbose, -v       Show detailed output
    --debug             Enable debug logging

EXAMPLES:
    macos-prefs dump
    macos-prefs restore --dry-run
    macos-prefs restore
    macos-prefs backup
    macos-prefs diff

HELP_EOF
}

# Get list of preference domains to track
get_preference_domains() {
    cat << 'DOMAINS_EOF'
# System preferences
com.apple.dock
com.apple.finder
com.apple.desktopservices
com.apple.trackpad
com.apple.mouse
com.apple.keyboard
com.apple.menuextra.clock
com.apple.screensaver
com.apple.screencapture
com.apple.systempreferences
com.apple.LaunchServices
com.apple.loginwindow
com.apple.CrashReporter
com.apple.SoftwareUpdate
com.apple.TimeMachine
com.apple.ActivityMonitor
com.apple.TextEdit
com.apple.QuickTimePlayerX
com.apple.Preview
com.apple.Safari
com.apple.mail
com.apple.AddressBook
com.apple.iCal
com.apple.iTunes
com.apple.Photos
com.apple.Notes
com.apple.Reminders
com.apple.Maps
com.apple.FaceTime
com.apple.Messages
com.apple.AppStore
com.apple.systemuiserver
com.apple.spaces
com.apple.exposé
com.apple.universalaccess
com.apple.sound.beep.sound
com.apple.HIToolbox
com.apple.BluetoothAudioAgent
com.apple.NetworkBrowser
com.apple.print.PrintingPrefs
com.apple.security.authorization
com.apple.security.smartcard
NSGlobalDomain
# Third-party applications
com.microsoft.VSCode
com.github.xcode-actions.app
com.raycast.macos
com.knollsoft.Rectangle
com.tinyspeck.slackmacgap
com.spotify.client
com.google.Chrome
com.mozilla.firefox
DOMAINS_EOF
}

# Update domains file
update_domains() {
    log "INFO" "Updating preference domains list..."
    get_preference_domains > "$DOMAINS_FILE"
    log "INFO" "Updated domains file: $DOMAINS_FILE"
}

# Dump current preferences
dump_preferences() {
    local dry_run="${1:-false}"
    
    if [[ "$dry_run" == "true" ]]; then
        log "INFO" "DRY RUN: Would dump preferences to $PREFS_DIR"
        return 0
    fi
    
    log "INFO" "Dumping macOS preferences..."
    
    # Ensure domains file exists
    if [[ ! -f "$DOMAINS_FILE" ]]; then
        update_domains
    fi
    
    # Create comprehensive preference dump
    {
        echo "#!/usr/bin/env bash"
        echo "# macOS Preferences Restoration Script"
        echo "# Generated on: $(date)"
        echo "# Machine: $(hostname)"
        echo "# User: $(whoami)"
        echo "# macOS Version: $(sw_vers -productVersion)"
        echo ""
        echo "set -euo pipefail"
        echo ""
        echo "# Preference restoration"
        echo "echo 'Restoring macOS preferences...'"
        echo ""
    } > "$SYSTEM_PREFS"
    
    # Counter for progress
    local total_domains=$(grep -v '^#' "$DOMAINS_FILE" | grep -v '^$' | wc -l | tr -d ' ')
    local current=0
    
    # Process each domain
    while IFS= read -r domain; do
        # Skip comments and empty lines
        [[ "$domain" =~ ^#.*$ ]] || [[ -z "$domain" ]] && continue
        
        current=$((current + 1))
        log "INFO" "Processing domain $current/$total_domains: $domain"
        
        # Check if domain has any preferences
        if defaults read "$domain" &>/dev/null; then
            {
                echo "# $domain preferences"
                echo "echo 'Setting $domain preferences...'"
                
                # Get all preferences for this domain and convert to defaults write commands
                defaults read "$domain" 2>/dev/null | while IFS= read -r line; do
                    # This is a simplified approach - in practice you'd want more sophisticated parsing
                    echo "# $line" | head -1
                done
                
                echo ""
            } >> "$SYSTEM_PREFS"
        else
            log "DEBUG" "No preferences found for domain: $domain"
        fi
    done < "$DOMAINS_FILE"
    
    # Add system restart recommendations
    {
        echo "# System restart recommendations"
        echo "echo 'Preferences applied successfully!'"
        echo "echo 'Some changes may require:'"
        echo "echo '  - Dock restart: killall Dock'"
        echo "echo '  - Finder restart: killall Finder'"
        echo "echo '  - System UI restart: killall SystemUIServer'"
        echo "echo '  - Full logout/login for all changes'"
        echo ""
        echo "# Restart affected services"
        echo "echo 'Restarting system services...'"
        echo "killall Dock 2>/dev/null || true"
        echo "killall Finder 2>/dev/null || true"
        echo "killall SystemUIServer 2>/dev/null || true"
        echo ""
        echo "echo 'macOS preferences restoration complete!'"
    } >> "$SYSTEM_PREFS"
    
    # Make script executable
    chmod +x "$SYSTEM_PREFS"
    
    log "INFO" "Preferences dumped successfully!"
    log "INFO" "Restoration script: $SYSTEM_PREFS"
    log "INFO" "Total domains processed: $total_domains"
}

# Restore preferences
restore_preferences() {
    local dry_run="${1:-false}"
    local force="${2:-false}"
    
    if [[ ! -f "$SYSTEM_PREFS" ]]; then
        log "ERROR" "No preferences file found. Run 'macos-prefs dump' first."
        return 1
    fi
    
    if [[ "$dry_run" == "true" ]]; then
        log "INFO" "DRY RUN: Would execute restoration script:"
        log "INFO" "Script: $SYSTEM_PREFS"
        return 0
    fi
    
    if [[ "$force" != "true" ]]; then
        echo -e "${YELLOW}This will modify your macOS system preferences.${NC}"
        echo -e "${YELLOW}It's recommended to create a backup first.${NC}"
        echo ""
        read -p "Continue? (y/N): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            log "INFO" "Restoration cancelled by user"
            return 0
        fi
    fi
    
    log "INFO" "Creating backup before restoration..."
    backup_preferences
    
    log "INFO" "Restoring macOS preferences..."
    if bash "$SYSTEM_PREFS"; then
        log "INFO" "Preferences restored successfully!"
    else
        log "ERROR" "Failed to restore preferences"
        return 1
    fi
}

# Create backup
backup_preferences() {
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local backup_dir="$BACKUP_DIR/$timestamp"
    
    log "INFO" "Creating backup: $backup_dir"
    mkdir -p "$backup_dir"
    
    # Dump current preferences to backup
    PREFS_DIR="$backup_dir" dump_preferences false
    
    log "INFO" "Backup created: $backup_dir"
}

# Show differences
show_diff() {
    log "INFO" "Diff functionality would compare current vs stored preferences"
    log "INFO" "This is a placeholder for now"
}

# List domains
list_domains() {
    if [[ ! -f "$DOMAINS_FILE" ]]; then
        update_domains
    fi
    
    log "INFO" "Tracked preference domains:"
    echo ""
    
    while IFS= read -r domain; do
        if [[ "$domain" =~ ^#.*$ ]]; then
            echo -e "${BLUE}$domain${NC}"
        elif [[ -n "$domain" ]]; then
            if defaults read "$domain" &>/dev/null; then
                echo -e "${GREEN}✓${NC} $domain"
            else
                echo -e "${YELLOW}○${NC} $domain (no preferences)"
            fi
        fi
    done < "$DOMAINS_FILE"
}

# Main function
main() {
    local command="${1:-}"
    local dry_run=false
    local force=false
    local quiet=false
    
    # Parse options
    while [[ $# -gt 0 ]]; do
        case $1 in
            --dry-run)
                dry_run=true
                shift
                ;;
            --force)
                force=true
                shift
                ;;
            --quiet|-q)
                quiet=true
                shift
                ;;
            --verbose|-v)
                # verbose=true
                shift
                ;;
            --debug)
                DEBUG=1
                shift
                ;;
            --help|-h)
                show_help
                exit 0
                ;;
            -*)
                log "ERROR" "Unknown option: $1"
                exit 1
                ;;
            *)
                if [[ -z "$command" ]]; then
                    command="$1"
                fi
                shift
                ;;
        esac
    done
    
    # Set quiet mode
    if [[ "$quiet" == "true" ]]; then
        exec 1>/dev/null
    fi
    
    # Execute command
    case "$command" in
        dump)
            dump_preferences "$dry_run"
            ;;
        restore)
            restore_preferences "$dry_run" "$force"
            ;;
        diff)
            show_diff
            ;;
        backup)
            backup_preferences
            ;;
        list)
            list_domains
            ;;
        domains)
            update_domains
            ;;
        help|"")
            show_help
            ;;
        *)
            log "ERROR" "Unknown command: $command"
            show_help
            exit 1
            ;;
    esac
}

# Run main function
main "$@"
