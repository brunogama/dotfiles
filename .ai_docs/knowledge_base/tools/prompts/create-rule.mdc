---
description: Template for creating new Cursor rules with optimized YAML structure for LLM processing
globs: **/*.mdc
alwaysApply: false
---

# Cursor Rule Creation Template

## Introduction

This template provides a structured approach for creating effective Cursor Project Rules optimized for LLM processing. Rules are `.mdc` files that guide AI behavior for specific file patterns and project conventions.

## Rule Structure Components

### YAML Frontmatter (Required)
```yaml
---
description: Clear, concise description starting with action words
globs: specific file patterns that trigger rule activation
alwaysApply: false # Set to true only for critical universal rules
---
```

### Content Organization
1. **Introduction/Problem**: What the rule solves and why it matters
2. **Pattern Description**: Clear conventions with code examples
3. **Implementation Steps**: Step-by-step guidance when applicable
4. **Real-World Examples**: Links to actual code in the repository
5. **Common Pitfalls**: Anti-patterns and how to avoid them

## Rule Types and Activation

### Global Rules
- **Purpose**: Critical universal guidelines
- **Activation**: Always included in context
- **Best Practice**: Keep concise, use sparingly
- **YAML**: `alwaysApply: true`

### Automatic Rules
- **Purpose**: File-type specific guidance
- **Activation**: When working with matching files
- **Best Practice**: Focus on universal patterns for file types
- **Example**: `globs: **/*.swift` for Swift style guide

### Agent-Requested Rules
- **Purpose**: Detailed guidance for specific tasks
- **Activation**: AI may choose based on description and task
- **Best Practice**: Include detailed examples and clear descriptions
- **Example**: `description: "Guidance for API design when creating endpoints"`

### Manual Rules
- **Purpose**: Situational instructions requiring human activation
- **Activation**: Only when explicitly invoked
- **Best Practice**: Can be verbose, highly detailed
- **YAML**: `alwaysApply: false`, empty `globs`

## YAML Frontmatter Guidelines

### Critical Requirements
- **First Content**: YAML frontmatter must be the absolute first content
- **No Leading Characters**: Any leading spaces, lines, or characters prevent loading
- **UTF-8 Encoding**: Ensure standard encoding for proper parsing

### Description Field
- **Action-Oriented**: Start with "Guidelines for..." or "Instructions on..."
- **Concise**: Keep under 100 characters for optimal LLM processing
- **Specific**: Include key terms that help AI selection

### Globs Patterns
- **Specificity**: More specific patterns avoid unintended overlaps
- **Examples**:
  - `**/*.swift` (All Swift files)
  - `Core/**/*.swift` (Core module Swift files)
  - `Apps/**/Package.swift` (App package files)
  - `**/*.{json,yaml,yml}` (Configuration files)

### AlwaysApply Setting
- **Default**: `false` for most rules
- **Use `true`**: Only for critical universal guidelines
- **Impact**: Always consumes AI context when `true`

## Advanced Features

### File References (`@file`)
```markdown
@file ../Package.swift
@file ../Config/build.sh
@file ./docs/ARCHITECTURE.md
```

**Guidelines**:
- Use relative paths from `.cursor/rules/`
- Include only essential context files
- Avoid excessive context to prevent overload
- Place after frontmatter, before main content

### Code Block Formatting
```swift
// Always use language-specific fenced blocks
func example() -> String {
    return "Properly formatted Swift code"
}
```

**Requirements**:
- Use language specifiers for syntax highlighting
- Keep examples focused and relevant
- Include comments for clarity

## Best Practices

### Rule Design Principles
- **Specificity**: Use narrow, focused globs to avoid overlaps
- **Modularity**: Break complex domains into smaller, focused rules
- **Clarity**: Write descriptions that help AI selection
- **Maintenance**: Keep rules updated as conventions evolve

### Content Guidelines
- **Action-Oriented**: Use "prefer", "consider", "typically" over rigid commands
- **Pattern-Focused**: Define repeatable patterns, not one-off fixes
- **Example-Rich**: Include real code examples from the repository
- **Error-Prevention**: Document common pitfalls and solutions

### Team Collaboration
- **Version Control**: Commit `.cursor/rules` to repository
- **Conventions**: Establish naming and structuring standards
- **Review Process**: Consider code reviews for important rules
- **Onboarding**: Use rules as living documentation

## Troubleshooting

### Common Issues
- **Rule Not Activating**: Check YAML frontmatter is first content
- **Pattern Mismatch**: Verify globs correctly match target files
- **File Path Errors**: Ensure @file directives use correct relative paths
- **Encoding Issues**: Use UTF-8 encoding for all .mdc files

### Rule Selection Logic
- **Specificity**: More specific globs preferred over broad patterns
- **Description Quality**: Clear descriptions help AI selection
- **Context Impact**: Consider how many rules activate simultaneously

## Swift Rule Example

```yaml
---
description: Guidelines for Swift module structure and Package.swift organization
globs: **/Package.swift
alwaysApply: false
---

@file ../Package.swift
@file ../Config/build.sh

# Swift Module Structure

## Introduction

This rule defines standard patterns for Swift module organization, Package.swift structure, and dependency management to ensure consistency across the project.

## Pattern Description

### Package.swift Structure
```swift
// swift-tools-version: 5.9
import PackageDescription

let package = Package(
    name: "ModuleName",
    platforms: [.iOS(.v15)],
    products: [
        .library(name: "ModuleName", targets: ["ModuleName"])
    ],
    dependencies: [
        .package(path: "../Core/Commons"),
        .package(path: "../Shared/Utils")
    ],
    targets: [
        .target(
            name: "ModuleName",
            dependencies: ["Commons", "Utils"]
        ),
        .testTarget(
            name: "ModuleNameTests",
            dependencies: ["ModuleName"]
        )
    ]
)
```

### Directory Structure
```
ModuleName/
├── Package.swift
├── Sources/
│   └── ModuleName/
│       ├── Models/
│       ├── Services/
│       └── Views/
└── Tests/
    └── ModuleNameTests/
```

## Implementation Steps

1. Create Package.swift with proper dependencies
2. Organize Sources/ModuleName/ with logical subdirectories
3. Include test target with matching structure
4. Use relative paths for internal dependencies

## Real-World Examples

* @Core/Commons/Package.swift
* @Apps/BaseApp/Package.swift

## Common Pitfalls

* Missing test targets in Package.swift
* Incorrect dependency paths
* Overly complex module structure
* Missing platform specifications
```

## Quick Start Template

```yaml
---
description: Guidelines for [specific purpose or pattern]
globs: [file pattern that triggers rule]
alwaysApply: false
---

# [Rule Name]

## Introduction

[Brief explanation of what this rule covers and why it matters]

## Pattern Description

[Clear description with code examples]

## Real-World Examples

* @Link to actual code in repository

## Common Pitfalls

* [Common mistake with explanation]
* [Another common issue]
```
