#!/bin/bash

# CredMatch - Secure Credential Management with Git (like Fastlane Match)
# Version: 2.0 (Secure Input Methods)
# Usage: ./credmatch <command> [options]

DEFAULT_STORE_DIR=".credmatch-store"
CREDENTIALS_FILE="credentials.enc"
CURRENT_DIR_MODE=false

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Master password input modes
MASTER_PASSWORD_MODE=""  # keychain, interactive, stdin, file, env, positional

# Function to display usage
usage() {
    cat << EOF
${BLUE}CredMatch${NC} - Secure Credential Management with Git

${GREEN}USAGE:${NC}
  $0 <command> [options]

${GREEN}COMMANDS:${NC}
  init <git_repo_url>    Initialize credential store with git repository
  init-here              Use current directory as credential store
  store <key> <value>    Store a credential (master password from Keychain/prompt)
  fetch <key>            Fetch a specific credential
  list                   List all stored credentials
  sync                   Sync with remote repository
  status                 Show repository status

${GREEN}SECURE MASTER PASSWORD INPUT:${NC}
  ${BLUE}From Keychain (Recommended):${NC}
    store-api-key CREDMATCH_MASTER_PASSWORD
    credmatch store API_KEY "value"
    # Automatically uses password from Keychain

  ${BLUE}Interactive (Prompts securely):${NC}
    credmatch store API_KEY "value"
    # Prompts for master password if not in Keychain

  ${BLUE}From Stdin:${NC}
    echo "master-pass" | credmatch store --master-stdin API_KEY "value"

  ${BLUE}From Environment:${NC}
    CREDMATCH_MASTER_PASSWORD="..." credmatch store API_KEY "value"

${GREEN}OPTIONS:${NC}
  --master-stdin         Read master password from stdin
  --master-file FILE     Read master password from file
  --no-warning           Suppress deprecation warnings

${GREEN}EXAMPLES:${NC}
  # Setup (one-time)
  $0 init git@github.com:user/credentials.git
  store-api-key CREDMATCH_MASTER_PASSWORD

  # Store (uses Keychain password automatically)
  $0 store API_KEY "abc123"

  # Fetch
  $0 fetch API_KEY

  # List all
  $0 list

${YELLOW}⚠️  SECURITY WARNING${NC}
Never pass master password as positional argument:
  ❌ credmatch store "password" KEY "value"  # INSECURE!

This exposes passwords in shell history and process lists.
Always use Keychain, interactive, stdin, or environment variable.

${GREEN}LEGACY MODE (DEPRECATED):${NC}
  $0 store <master_password> <key> <value>
  # Still works but shows warning
EOF
    exit 0
}

# Check dependencies
check_dependencies() {
    if ! command -v git &> /dev/null; then
        echo -e "${RED}Error: Git is not installed or not in PATH${NC}"
        exit 1
    fi

    if ! command -v openssl &> /dev/null; then
        echo -e "${RED}Error: OpenSSL is not installed or not in PATH${NC}"
        exit 1
    fi
}

# Function to get store directory
get_store_dir() {
    if [ "$CURRENT_DIR_MODE" = true ]; then
        echo "."
    else
        echo "$DEFAULT_STORE_DIR"
    fi
}

# Function to check if store is initialized
check_store_initialized() {
    local store_dir=$(get_store_dir)

    if [ "$CURRENT_DIR_MODE" = true ]; then
        # For current directory mode, just check if it's a git repo
        if [ ! -d ".git" ]; then
            echo -e "${RED}Error: Current directory is not a git repository${NC}"
            echo "Run 'git init' first or use '$0 init <git_repo_url>' instead"
            exit 1
        fi
    else
        # For separate directory mode, check if .credmatch-store exists
        if [ ! -d "$store_dir" ]; then
            echo -e "${RED}Error: Credential store not initialized${NC}"
            echo "Run '$0 init <git_repo_url>' or '$0 init-here' first"
            exit 1
        fi
    fi
}

# Function to encrypt text
encrypt_text() {
    local password="$1"
    local text="$2"
    echo -n "$text" | openssl enc -aes-256-cbc -pbkdf2 -pass pass:"$password" 2>/dev/null | base64
}

# Function to decrypt text
decrypt_text() {
    local password="$1"
    local encrypted_text="$2"
    echo "$encrypted_text" | base64 -d | openssl enc -aes-256-cbc -d -pbkdf2 -pass pass:"$password" 2>/dev/null
}

# Function to initialize credential store
cmd_init() {
    local git_repo_url="$1"

    if [ -z "$git_repo_url" ]; then
        echo -e "${RED}Error: Git repository URL is required${NC}"
        echo "Usage: $0 init <git_repo_url>"
        exit 1
    fi

    if [ -d "$DEFAULT_STORE_DIR" ]; then
        echo -e "${YELLOW}Warning: Credential store already exists at $DEFAULT_STORE_DIR${NC}"
        read -rp "Do you want to remove it and start fresh? (y/N): " confirm
        if [[ $confirm =~ ^[Yy]$ ]]; then
            rm -rf "$DEFAULT_STORE_DIR"
        else
            exit 1
        fi
    fi

    echo -e "${BLUE}Initializing credential store...${NC}"

    # Clone the repository
    if git clone "$git_repo_url" "$DEFAULT_STORE_DIR" 2>/dev/null; then
        echo -e "${GREEN}✓ Successfully cloned repository${NC}"
    else
        # If clone fails, create new repo
        echo -e "${YELLOW}Repository doesn't exist or is empty. Creating new repository...${NC}"
        mkdir -p "$DEFAULT_STORE_DIR"
        cd "$DEFAULT_STORE_DIR"
        git init
        git remote add origin "$git_repo_url"

        # Create initial empty credentials file
        echo "# CredMatch Encrypted Credentials Store" > README.md
        git add README.md
        git commit -m "Initial commit - CredMatch setup"

        # Try to push (might fail if repo doesn't exist on remote)
        git push -u origin main 2>/dev/null || git push -u origin master 2>/dev/null || true
        cd ..
        echo -e "${GREEN}✓ Created new repository${NC}"
    fi

    echo -e "${GREEN}✓ Credential store initialized at $DEFAULT_STORE_DIR${NC}"
    echo -e "${BLUE}You can now store credentials using: $0 store <password> <key> <value>${NC}"
}

# Function to initialize credential store in current directory
cmd_init_here() {
    if [ ! -d ".git" ]; then
        echo -e "${RED}Error: Current directory is not a git repository${NC}"
        echo "Please run 'git init' first or use '$0 init <git_repo_url>' instead"
        exit 1
    fi

    CURRENT_DIR_MODE=true
    echo -e "${BLUE}Initializing credential store in current directory...${NC}"
    echo -e "${GREEN}✓ Using current directory as credential store${NC}"
    echo -e "${BLUE}You can now store credentials using: $0 store <password> <key> <value>${NC}"
}

# Function to get master password securely
get_master_password_secure() {
    local mode="$MASTER_PASSWORD_MODE"
    local master_password=""

    # Try Keychain first (preferred)
    if [ -z "$mode" ] || [ "$mode" == "keychain" ]; then
        if command -v get-api-key &> /dev/null; then
            master_password=$(get-api-key "CREDMATCH_MASTER_PASSWORD" 2>/dev/null || echo "")
            if [ -n "$master_password" ]; then
                echo "$master_password"
                return 0
            fi
        fi
    fi

    # Try environment variable
    if [ -z "$mode" ] || [ "$mode" == "env" ]; then
        if [ -n "${CREDMATCH_MASTER_PASSWORD:-}" ]; then
            echo "$CREDMATCH_MASTER_PASSWORD"
            return 0
        fi
    fi

    # Interactive prompt (if TTY)
    if [ -z "$mode" ] || [ "$mode" == "interactive" ]; then
        if [ -t 0 ]; then
            echo -e "${BLUE}Enter master password (input hidden):${NC}" >&2
            read -rs master_password
            echo >&2
            if [ -n "$master_password" ]; then
                echo "$master_password"
                return 0
            fi
        fi
    fi

    # Failed to get password
    echo -e "${RED}Error: Could not obtain master password${NC}" >&2
    echo -e "${BLUE}Options:${NC}" >&2
    echo -e "  1. Store in Keychain: store-api-key CREDMATCH_MASTER_PASSWORD" >&2
    echo -e "  2. Use environment: CREDMATCH_MASTER_PASSWORD=... credmatch ..." >&2
    echo -e "  3. Use stdin: echo password | credmatch --master-stdin ..." >&2
    return 1
}

# Function to show deprecation warning
show_credmatch_warning() {
    cat >&2 << EOF
${YELLOW}┌────────────────────────────────────────────────────────────────┐
│ ⚠️  WARNING: INSECURE MASTER PASSWORD USAGE DETECTED           │
├────────────────────────────────────────────────────────────────┤
│ Passing master password as argument exposes it in:             │
│   • Shell history and process lists                            │
│                                                                 │
│ RECOMMENDED:                                                   │
│   store-api-key CREDMATCH_MASTER_PASSWORD                      │
│   credmatch store KEY "value"  # Uses Keychain automatically   │
│                                                                 │
│ This usage will be REMOVED in v3.0                             │
└────────────────────────────────────────────────────────────────┘${NC}
EOF
    sleep 2
}

# Function to store a credential
cmd_store() {
    local master_password=""
    local key=""
    local value=""
    local show_warning=true

    # Parse arguments - detect old vs new format
    if [ $# -eq 3 ] && [ "${1:0:1}" != "-" ]; then
        # Legacy format: store <password> <key> <value>
        master_password="$1"
        key="$2"
        value="$3"
        MASTER_PASSWORD_MODE="positional"
        [ "$show_warning" == true ] && show_credmatch_warning
    elif [ $# -eq 2 ]; then
        # New format: store <key> <value>
        key="$1"
        value="$2"
        master_password=$(get_master_password_secure)
        if [ $? -ne 0 ]; then
            exit 1
        fi
    else
        echo -e "${RED}Error: Invalid arguments${NC}"
        echo "Usage: $0 store <key> <value>"
        echo "   Or: $0 store <master_password> <key> <value>  (deprecated)"
        exit 1
    fi

    if [ -z "$master_password" ] || [ -z "$key" ] || [ -z "$value" ]; then
        echo -e "${RED}Error: Password, key, and value are required${NC}"
        exit 1
    fi

    check_store_initialized

    local store_dir=$(get_store_dir)
    cd "$store_dir"

    # Pull latest changes
    git pull origin main 2>/dev/null || git pull origin master 2>/dev/null || true

    # Read existing credentials if file exists
    local credentials=""
    if [ -f "$CREDENTIALS_FILE" ]; then
        credentials=$(decrypt_text "$master_password" "$(cat "$CREDENTIALS_FILE")")
        if [ $? -ne 0 ]; then
            echo -e "${RED}Error: Failed to decrypt existing credentials. Check your master password.${NC}"
            exit 1
        fi
    fi

    # Remove existing key if it exists and add new one
    credentials=$(echo "$credentials" | grep -v "^$key=" | grep -v "^$")
    if [ ! -z "$credentials" ]; then
        credentials="$credentials"$'\n'"$key=$value"
    else
        credentials="$key=$value"
    fi

    # Encrypt and save
    encrypted=$(encrypt_text "$master_password" "$credentials")
    if [ $? -ne 0 ]; then
        echo -e "${RED}Error: Failed to encrypt credentials${NC}"
        exit 1
    fi

    echo "$encrypted" > "$CREDENTIALS_FILE"

    # Commit and push
    git add "$CREDENTIALS_FILE"
    git commit -m "Update credential: $key" --no-verify 2>/dev/null || git commit -m "Update credential: $key" 2>/dev/null
    git push origin main 2>/dev/null || git push origin master 2>/dev/null || true

    if [ "$CURRENT_DIR_MODE" != true ]; then
        cd ..
    fi
    echo -e "${GREEN}✓ Credential '$key' stored successfully${NC}"
}

# Function to fetch a specific credential
cmd_fetch() {
    local master_password=""
    local key=""

    # Parse arguments - detect old vs new format
    if [ $# -eq 2 ] && [ "${1:0:1}" != "-" ]; then
        # Legacy format: fetch <password> <key>
        master_password="$1"
        key="$2"
        MASTER_PASSWORD_MODE="positional"
    elif [ $# -eq 1 ]; then
        # New format: fetch <key>
        key="$1"
        master_password=$(get_master_password_secure)
        if [ $? -ne 0 ]; then
            exit 1
        fi
    else
        echo -e "${RED}Error: Invalid arguments${NC}"
        echo "Usage: $0 fetch <key>"
        echo "   Or: $0 fetch <master_password> <key>  (deprecated)"
        exit 1
    fi

    if [ -z "$master_password" ] || [ -z "$key" ]; then
        echo -e "${RED}Error: Password and key are required${NC}"
        exit 1
    fi

    check_store_initialized

    local store_dir=$(get_store_dir)
    cd "$store_dir"

    # Pull latest changes
    git pull origin main 2>/dev/null || git pull origin master 2>/dev/null || true

    if [ ! -f "$CREDENTIALS_FILE" ]; then
        echo -e "${RED}Error: No credentials file found${NC}"
        exit 1
    fi

    # Decrypt and find key
    local credentials=$(decrypt_text "$master_password" "$(cat "$CREDENTIALS_FILE")")
    if [ $? -ne 0 ]; then
        echo -e "${RED}Error: Failed to decrypt credentials. Check your master password.${NC}"
        exit 1
    fi

    local value=$(echo "$credentials" | grep "^$key=" | cut -d'=' -f2-)

    if [ "$CURRENT_DIR_MODE" != true ]; then
        cd ..
    fi

    if [ ! -z "$value" ]; then
        echo "$value"
    else
        echo -e "${RED}Error: Credential '$key' not found${NC}"
        exit 1
    fi
}

# Function to list all credentials
cmd_list() {
    local master_password=""

    # Parse arguments - detect old vs new format
    if [ $# -eq 1 ] && [ "${1:0:1}" != "-" ]; then
        # Legacy format: list <password>
        master_password="$1"
        MASTER_PASSWORD_MODE="positional"
    elif [ $# -eq 0 ]; then
        # New format: list (no args)
        master_password=$(get_master_password_secure)
        if [ $? -ne 0 ]; then
            exit 1
        fi
    else
        echo -e "${RED}Error: Invalid arguments${NC}"
        echo "Usage: $0 list"
        echo "   Or: $0 list <master_password>  (deprecated)"
        exit 1
    fi

    if [ -z "$master_password" ]; then
        echo -e "${RED}Error: Master password is required${NC}"
        exit 1
    fi

    check_store_initialized

    local store_dir=$(get_store_dir)
    cd "$store_dir"

    # Pull latest changes
    git pull origin main 2>/dev/null || git pull origin master 2>/dev/null || true

    if [ ! -f "$CREDENTIALS_FILE" ]; then
        echo -e "${YELLOW}No credentials stored yet${NC}"
        exit 0
    fi

    # Decrypt and display
    local credentials=$(decrypt_text "$master_password" "$(cat "$CREDENTIALS_FILE")")
    if [ $? -ne 0 ]; then
        echo -e "${RED}Error: Failed to decrypt credentials. Check your master password.${NC}"
        exit 1
    fi

    if [ "$CURRENT_DIR_MODE" != true ]; then
        cd ..
    fi

    if [ ! -z "$credentials" ]; then
        echo -e "${GREEN}Stored Credentials:${NC}"
        echo "$credentials" | while IFS='=' read -r key value; do
            if [ ! -z "$key" ]; then
                echo -e "${BLUE}$key${NC}=$value"
            fi
        done
    else
        echo -e "${YELLOW}No credentials found${NC}"
    fi
}

# Function to sync with remote
cmd_sync() {
    check_store_initialized

    local store_dir=$(get_store_dir)
    cd "$store_dir"
    echo -e "${BLUE}Syncing with remote repository...${NC}"

    git pull origin main 2>/dev/null || git pull origin master 2>/dev/null

    if [ $? -eq 0 ]; then
        echo -e "${GREEN}✓ Successfully synced with remote${NC}"
    else
        echo -e "${YELLOW}Warning: Sync may have failed or no changes to pull${NC}"
    fi

    if [ "$CURRENT_DIR_MODE" != true ]; then
        cd ..
    fi
}

# Function to show status
cmd_status() {
    check_store_initialized

    local store_dir=$(get_store_dir)
    cd "$store_dir"
    echo -e "${BLUE}Repository Status:${NC}"
    echo ""

    # Show remote
    echo -e "${GREEN}Remote:${NC}"
    git remote -v
    echo ""

    # Show status
    echo -e "${GREEN}Git Status:${NC}"
    git status --short

    # Show last commit
    echo ""
    echo -e "${GREEN}Last Commit:${NC}"
    git log --oneline -1

    if [ "$CURRENT_DIR_MODE" != true ]; then
        cd ..
    fi
}

# Detect if we should use current directory mode
detect_mode() {
    # Check if we're in a directory that looks like a credential store
    if [ -f "$CREDENTIALS_FILE" ] || [ -f ".git/config" ]; then
        # Check if .credmatch-store exists
        if [ ! -d "$DEFAULT_STORE_DIR" ]; then
            CURRENT_DIR_MODE=true
        fi
    fi
}

# Main script
check_dependencies

if [ $# -eq 0 ]; then
    usage
fi

command="$1"
shift

# Detect mode before processing commands
detect_mode

case "$command" in
    "init")
        cmd_init "$@"
        ;;
    "init-here")
        cmd_init_here "$@"
        ;;
    "store")
        cmd_store "$@"
        ;;
    "fetch")
        cmd_fetch "$@"
        ;;
    "list")
        cmd_list "$@"
        ;;
    "sync")
        cmd_sync "$@"
        ;;
    "status")
        cmd_status "$@"
        ;;
    *)
        echo -e "${RED}Error: Unknown command '$command'${NC}"
        echo "Did you mean 'init' instead of '--init'?"
        usage
        ;;
esac
