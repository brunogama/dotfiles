#!/usr/bin/env bash
#
# clear-secret-history - Detect and remove potentially exposed secrets from shell history
# Version: 1.0
#
# Scans shell history for credential commands with suspicious patterns
# and helps remove them securely.
#

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
BOLD='\033[1m'
NC='\033[0m'

# Script name
readonly SCRIPT_NAME="$(basename "$0")"

# Patterns that likely contain secrets
DANGEROUS_PATTERNS=(
    'store-api-key "[^"]+" "[^"]+"'  # store-api-key KEY "value"
    'credmatch store "[^"]+" "[^"]+" "[^"]+"'  # credmatch store "pass" "key" "value"
    'export [A-Z_]*PASSWORD=[^[:space:]]'  # export PASSWORD=value
    'export [A-Z_]*SECRET=[^[:space:]]'  # export SECRET=value
    'export [A-Z_]*KEY=[^[:space:]]'  # export KEY=value
    'export [A-Z_]*TOKEN=[^[:space:]]'  # export TOKEN=value
    '[A-Z_]*PASSWORD="[^"]*"'  # PASSWORD="value" inline
    '[A-Z_]*SECRET="[^"]*"'  # SECRET="value" inline
    'curl.*-H.*Authorization:.*Bearer'  # curl with auth header
    'mysql.*-p[^[:space:]]'  # mysql -ppassword
    'psql.*postgresql://[^[:space:]]*:[^[:space:]]*@'  # postgres connection string
)

# Function to display usage
usage() {
    cat << EOF
${BLUE}${BOLD}clear-secret-history${NC} - Remove potentially exposed secrets from shell history

${GREEN}USAGE:${NC}
  $SCRIPT_NAME [options]

${GREEN}OPTIONS:${NC}
  --dry-run        Show what would be removed without actually removing
  --auto           Remove without prompting (use with caution)
  --all-shells     Check all shell history files (zsh, bash, fish)
  -h, --help       Show this help

${GREEN}WHAT IT DOES:${NC}
  1. Scans shell history for dangerous patterns
  2. Shows preview of potentially exposed secrets
  3. Prompts for confirmation (unless --auto)
  4. Removes matching lines from history files
  5. Creates backup before modification

${GREEN}PATTERNS DETECTED:${NC}
  • store-api-key with positional value arguments
  • credmatch store with positional password arguments
  • export commands with PASSWORD/SECRET/KEY/TOKEN
  • Inline password/secret variable assignments
  • curl commands with Authorization headers
  • Database connection strings with passwords

${GREEN}EXAMPLES:${NC}
  # Preview what would be removed
  $SCRIPT_NAME --dry-run

  # Interactive removal (recommended)
  $SCRIPT_NAME

  # Automatic removal (careful!)
  $SCRIPT_NAME --auto

  # Check all shells
  $SCRIPT_NAME --all-shells

${YELLOW}⚠️  WARNING${NC}
This tool attempts to detect exposed secrets, but may:
  • Miss some patterns
  • Flag false positives
  • Not catch all variations

${BOLD}Always review the preview before confirming removal!${NC}

${GREEN}NOTES:${NC}
  • Creates backup at ~/.{shell}_history.backup before changes
  • Only modifies history files in your home directory
  • Does not affect currently loaded shell history
  • Run 'history -c && history -r' to reload after cleanup

EOF
    exit 0
}

# Function to log messages
log_info() {
    echo -e "${BLUE}ℹ${NC} $*"
}

log_success() {
    echo -e "${GREEN}✓${NC} $*"
}

log_warning() {
    echo -e "${YELLOW}⚠${NC} $*"
}

log_error() {
    echo -e "${RED}✗${NC} $*" >&2
}

# Parse arguments
DRY_RUN=false
AUTO=false
ALL_SHELLS=false

while [[ $# -gt 0 ]]; do
    case "$1" in
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --auto)
            AUTO=true
            shift
            ;;
        --all-shells)
            ALL_SHELLS=true
            shift
            ;;
        -h|--help)
            usage
            ;;
        *)
            log_error "Unknown option: $1"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
done

# Determine which history files to check
HISTORY_FILES=()

if [[ "$ALL_SHELLS" == true ]]; then
    # Check all common shells
    [[ -f ~/.zsh_history ]] && HISTORY_FILES+=("$HOME/.zsh_history")
    [[ -f ~/.bash_history ]] && HISTORY_FILES+=("$HOME/.bash_history")
    [[ -f ~/.history ]] && HISTORY_FILES+=("$HOME/.history")
    [[ -f ~/.local/share/fish/fish_history ]] && HISTORY_FILES+=("$HOME/.local/share/fish/fish_history")
else
    # Check current shell's history
    if [[ -n "${ZSH_VERSION:-}" ]]; then
        [[ -f ~/.zsh_history ]] && HISTORY_FILES+=("$HOME/.zsh_history")
    elif [[ -n "${BASH_VERSION:-}" ]]; then
        [[ -f ~/.bash_history ]] && HISTORY_FILES+=("$HOME/.bash_history")
    else
        # Try to detect from $SHELL
        case "$SHELL" in
            */zsh)
                [[ -f ~/.zsh_history ]] && HISTORY_FILES+=("$HOME/.zsh_history")
                ;;
            */bash)
                [[ -f ~/.bash_history ]] && HISTORY_FILES+=("$HOME/.bash_history")
                ;;
            */fish)
                [[ -f ~/.local/share/fish/fish_history ]] && HISTORY_FILES+=("$HOME/.local/share/fish/fish_history")
                ;;
            *)
                log_warning "Unknown shell: $SHELL"
                log_info "Use --all-shells to check all history files"
                exit 1
                ;;
        esac
    fi
fi

if [[ ${#HISTORY_FILES[@]} -eq 0 ]]; then
    log_error "No history files found"
    exit 1
fi

log_info "Scanning ${#HISTORY_FILES[@]} history file(s)..."
echo ""

# Scan for dangerous patterns
declare -A MATCHES_BY_FILE

for history_file in "${HISTORY_FILES[@]}"; do
    log_info "Checking: $history_file"

    # Array to store matching line numbers
    declare -a MATCHES=()

    # Search for each pattern
    for pattern in "${DANGEROUS_PATTERNS[@]}"; do
        while IFS= read -r line_num; do
            if [[ -n "$line_num" ]]; then
                MATCHES+=("$line_num")
            fi
        done < <(grep -n -E "$pattern" "$history_file" 2>/dev/null | cut -d: -f1 || true)
    done

    # Remove duplicates and sort
    if [[ ${#MATCHES[@]} -gt 0 ]]; then
        UNIQUE_MATCHES=($(printf '%s\n' "${MATCHES[@]}" | sort -nu))
        MATCHES_BY_FILE["$history_file"]="${UNIQUE_MATCHES[*]}"

        log_warning "Found ${#UNIQUE_MATCHES[@]} potentially sensitive command(s)"
    else
        log_success "No sensitive patterns found"
    fi
done

echo ""

# Check if any matches found
TOTAL_MATCHES=0
for matches in "${MATCHES_BY_FILE[@]}"; do
    count=$(echo "$matches" | wc -w | tr -d ' ')
    TOTAL_MATCHES=$((TOTAL_MATCHES + count))
done

if [[ $TOTAL_MATCHES -eq 0 ]]; then
    log_success "No potentially exposed secrets found in history!"
    log_info "Your history appears clean."
    exit 0
fi

# Show preview
echo -e "${YELLOW}${BOLD}═══ PREVIEW OF POTENTIALLY SENSITIVE COMMANDS ═══${NC}"
echo ""

for history_file in "${!MATCHES_BY_FILE[@]}"; do
    matches="${MATCHES_BY_FILE[$history_file]}"

    echo -e "${BLUE}File: $history_file${NC}"
    echo ""

    for line_num in $matches; do
        # Get the actual line content
        line_content=$(sed -n "${line_num}p" "$history_file")

        # Mask potential secrets in preview
        masked_line=$(echo "$line_content" | sed -E \
            -e 's/(store-api-key [^ ]+) "[^"]+"/\1 "[REDACTED]"/g' \
            -e 's/(credmatch store) "[^"]+" ("[^"]+" "[^"]+")/\1 [REDACTED] \2/g' \
            -e 's/(PASSWORD|SECRET|KEY|TOKEN)=[^ ]+/\1=[REDACTED]/g' \
            -e 's/(PASSWORD|SECRET|KEY|TOKEN)="[^"]+"/\1="[REDACTED]"/g' \
            -e 's/(Bearer) [^ ]+/\1 [REDACTED]/g' \
            -e 's/(-p)[^ ]+/\1[REDACTED]/g' \
            -e 's|postgresql://([^:]+):[^@]+@|postgresql://\1:[REDACTED]@|g'
        )

        echo -e "  ${RED}Line $line_num:${NC} $masked_line"
    done
    echo ""
done

echo -e "${YELLOW}${BOLD}══════════════════════════════════════════════════${NC}"
echo ""

# Dry run exit
if [[ "$DRY_RUN" == true ]]; then
    log_info "Dry-run mode: No changes made"
    log_info "Run without --dry-run to remove these commands"
    exit 0
fi

# Confirmation prompt
if [[ "$AUTO" != true ]]; then
    echo -e "${YELLOW}${BOLD}Found $TOTAL_MATCHES potentially sensitive command(s)${NC}"
    echo ""
    read -rp "Remove these from history? (y/N): " confirm

    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
        log_info "Operation cancelled. No changes made."
        exit 0
    fi
fi

# Perform removal
echo ""
log_info "Removing sensitive commands from history..."

for history_file in "${!MATCHES_BY_FILE[@]}"; do
    matches="${MATCHES_BY_FILE[$history_file]}"

    # Create backup
    backup_file="${history_file}.backup.$(date +%Y%m%d_%H%M%S)"
    cp "$history_file" "$backup_file"
    log_info "Backup created: $backup_file"

    # Remove lines (in reverse order to maintain line numbers)
    temp_file=$(mktemp)
    line_nums_reversed=$(echo "$matches" | tr ' ' '\n' | sort -rn)

    cp "$history_file" "$temp_file"

    for line_num in $line_nums_reversed; do
        sed -i.tmp "${line_num}d" "$temp_file"
        rm -f "${temp_file}.tmp"  # Remove sed backup file
    done

    # Replace original
    mv "$temp_file" "$history_file"

    count=$(echo "$matches" | wc -w | tr -d ' ')
    log_success "Removed $count line(s) from $(basename "$history_file")"
done

echo ""
log_success "History cleanup complete!"
echo ""
log_info "Next steps:"
echo "  1. Reload history in current shell: ${BOLD}history -c && history -r${NC}"
echo "  2. Secure future usage:"
echo "     • Use ${BOLD}store-api-key KEY${NC} (interactive mode)"
echo "     • Use ${BOLD}credmatch${NC} with Keychain password"
echo "  3. Backups saved in case you need to restore"
echo ""
log_warning "Remember: Already exposed secrets should be rotated!"
log_info "Consider changing any passwords/keys that were in your history."
