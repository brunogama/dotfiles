#!/bin/bash
#
# store-api-key - Store API keys securely in macOS Keychain
# Version: 2.0 (Secure Input Methods)
#
# Usage: store-api-key <service_name> [options]
#
# ⚠️  SECURITY WARNING
# Never pass secrets as command-line arguments!
# They are exposed in shell history and process lists.
#
# SECURE METHODS (Recommended):
#   store-api-key OPENAI_API_KEY                    # Interactive (prompts securely)
#   cat secret.txt | store-api-key KEY --stdin      # From stdin
#   store-api-key KEY --from-file ~/.secrets/key    # From file
#
# LEGACY (INSECURE - Deprecated):
#   store-api-key KEY "value"                       # Will show warning
#

set -euo pipefail

# Prevent command from being saved in history (HISTCONTROL)
HISTCONTROL=ignorespace:ignoredups

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Script name
readonly SCRIPT_NAME="$(basename "$0")"

# Input modes
INPUT_MODE=""  # interactive, stdin, file, positional
INPUT_FILE=""
FORCE_UPDATE=false
NO_WARNING=false

# Sensitive variables (cleared on exit)
API_KEY=""
SERVICE_NAME=""

# Function to clean up securely when script exits
cleanup() {
    API_KEY=""
    SERVICE_NAME=""
    INPUT_FILE=""
    { history -c; } 2>/dev/null || true
}
trap 'cleanup' EXIT INT TERM

# Function to display usage information
usage() {
    cat << EOF
${BLUE}store-api-key${NC} - Store API keys securely in macOS Keychain

${GREEN}USAGE:${NC}
  $SCRIPT_NAME <service_name> [options]

${GREEN}SECURE INPUT METHODS (Recommended):${NC}
  ${BLUE}Interactive Mode (Default):${NC}
    $SCRIPT_NAME OPENAI_API_KEY
    # Prompts securely, input hidden, no shell history exposure

  ${BLUE}Stdin Mode (For Automation):${NC}
    echo "secret" | $SCRIPT_NAME OPENAI_API_KEY --stdin
    cat ~/.secrets/api.key | $SCRIPT_NAME OPENAI_API_KEY --stdin

  ${BLUE}File Mode (For Persistent Secrets):${NC}
    $SCRIPT_NAME OPENAI_API_KEY --from-file ~/.secrets/api.key
    # File must have permissions 600 (owner read/write only)

${GREEN}OPTIONS:${NC}
  --stdin          Read API key from stdin
  --from-file FILE Read API key from file (checks permissions)
  --force          Override existing key without confirmation
  --no-warning     Suppress deprecation warnings (legacy mode)
  -h, --help       Show this help

${GREEN}EXAMPLES:${NC}
  # Interactive (most secure for manual use)
  $SCRIPT_NAME OPENAI_API_KEY

  # From stdin (best for scripts)
  echo "\$SECRET" | $SCRIPT_NAME OPENAI_API_KEY --stdin

  # From file (best for config-based secrets)
  $SCRIPT_NAME OPENAI_API_KEY --from-file ~/.secrets/openai.key

  # Force update without confirmation
  $SCRIPT_NAME OPENAI_API_KEY --force

${YELLOW}⚠️  SECURITY WARNING${NC}
Never pass secrets as positional arguments:
  ❌ $SCRIPT_NAME KEY "secret-value"  # INSECURE!

This exposes secrets in:
  - Shell history (~/.zsh_history, ~/.bash_history)
  - Process lists (ps aux, top, htop)
  - Terminal recordings
  - System logs

${GREEN}LEGACY MODE (DEPRECATED):${NC}
  $SCRIPT_NAME <service_name> <api_key> [--force]
  # Still works but shows deprecation warning
  # Will be removed in v3.0

${GREEN}NOTES:${NC}
  - Requires macOS with 'security' command
  - Keys stored in login keychain
  - Use 'get-api-key' to retrieve stored keys

EOF
    exit 0
}

# Function to display error messages
error() {
    echo -e "${RED}Error:${NC} $1" >&2
    exit "${2:-1}"
}

# Function to log messages
log_info() {
    echo -e "${BLUE}ℹ${NC} $*" >&2
}

log_success() {
    echo -e "${GREEN}✓${NC} $*" >&2
}

log_warning() {
    echo -e "${YELLOW}⚠${NC} $*" >&2
}

# Function to show deprecation warning
show_deprecation_warning() {
    if [[ "$NO_WARNING" == false ]]; then
        cat >&2 << EOF
${YELLOW}┌────────────────────────────────────────────────────────────────┐
│ ⚠️  WARNING: INSECURE CREDENTIAL STORAGE DETECTED               │
├────────────────────────────────────────────────────────────────┤
│ Passing secrets as command arguments exposes them in:          │
│   • Shell history (~/.zsh_history, ~/.bash_history)            │
│   • Process lists (ps aux, top, htop)                          │
│   • Terminal recordings and logs                               │
│                                                                 │
│ RECOMMENDED SECURE METHODS:                                    │
│   1. Interactive:  $SCRIPT_NAME KEY                            │
│   2. Stdin:        echo ... | $SCRIPT_NAME KEY --stdin         │
│   3. File:         $SCRIPT_NAME KEY --from-file ~/.secrets/key │
│                                                                 │
│ This usage will be REMOVED in v3.0                             │
│ Use --no-warning to suppress this message                      │
└────────────────────────────────────────────────────────────────┘${NC}
EOF
        sleep 2  # Give user time to read
    fi
}

# Check if running on macOS
if [[ "$OSTYPE" != "darwin"* ]]; then
    error "This script requires macOS" 2
fi

# Check if security command is available
if ! command -v security &> /dev/null; then
    error "The 'security' command is not available" 2
fi

# Parse arguments
if [[ $# -lt 1 ]]; then
    usage
fi

# Check for help flag first
if [[ "$1" == "--help" || "$1" == "-h" ]]; then
    usage
fi

# Parse options
SERVICE_NAME="$1"
shift

while [[ $# -gt 0 ]]; do
    case "$1" in
        --stdin)
            if [[ -n "$INPUT_MODE" && "$INPUT_MODE" != "stdin" ]]; then
                error "Cannot combine --stdin with other input modes"
            fi
            INPUT_MODE="stdin"
            shift
            ;;
        --from-file)
            if [[ -n "$INPUT_MODE" && "$INPUT_MODE" != "file" ]]; then
                error "Cannot combine --from-file with other input modes"
            fi
            INPUT_MODE="file"
            if [[ $# -lt 2 ]]; then
                error "--from-file requires a file path"
            fi
            INPUT_FILE="$2"
            shift 2
            ;;
        --force)
            FORCE_UPDATE=true
            shift
            ;;
        --no-warning)
            NO_WARNING=true
            shift
            ;;
        -*)
            error "Unknown option: $1"
            ;;
        *)
            # Positional argument (legacy mode)
            if [[ -z "$INPUT_MODE" ]]; then
                INPUT_MODE="positional"
                API_KEY="$1"
                shift
            else
                error "Unexpected argument: $1"
            fi
            ;;
    esac
done

# Validate service name
if [[ -z "$SERVICE_NAME" ]]; then
    error "Service name cannot be empty" 3
fi

if ! [[ "$SERVICE_NAME" =~ ^[A-Za-z0-9_-]+$ ]]; then
    error "Service name must contain only letters, numbers, underscores, and dashes" 3
fi

# Determine input mode if not specified
if [[ -z "$INPUT_MODE" ]]; then
    if [[ -t 0 ]]; then
        # stdin is a terminal, use interactive mode
        INPUT_MODE="interactive"
    else
        # stdin is piped, but no --stdin flag
        error "Not a TTY. Use --stdin to read from pipe, or run interactively" 2
    fi
fi

# Read API key based on input mode
case "$INPUT_MODE" in
    interactive)
        if [[ ! -t 0 ]]; then
            error "Interactive mode requires a TTY (terminal). Use --stdin or --from-file for non-interactive use" 2
        fi
        log_info "Enter value for '$SERVICE_NAME' (input will be hidden):"
        read -rs API_KEY
        echo >&2  # Newline after hidden input

        if [[ -z "$API_KEY" ]]; then
            error "API key cannot be empty" 3
        fi
        ;;

    stdin)
        # Read from stdin
        API_KEY=$(cat)

        if [[ -z "$API_KEY" ]]; then
            error "No input received from stdin" 3
        fi
        ;;

    file)
        # Validate file exists
        if [[ ! -f "$INPUT_FILE" ]]; then
            error "File not found: $INPUT_FILE" 3
        fi

        # Check file permissions (should be 600 or stricter)
        file_perms=$(stat -f "%Lp" "$INPUT_FILE" 2>/dev/null || stat -c "%a" "$INPUT_FILE" 2>/dev/null)

        if [[ "$file_perms" != "600" && "$file_perms" != "400" ]]; then
            log_warning "File permissions are $file_perms (expected 600 or 400)"
            log_warning "File: $INPUT_FILE"

            # Check if world or group readable
            if [[ "${file_perms:1:1}" != "0" || "${file_perms:2:1}" != "0" ]]; then
                error "File permissions too open ($file_perms). File must be readable only by owner (chmod 600 or 400)" 3
            fi
        fi

        # Read from file
        API_KEY=$(cat "$INPUT_FILE")

        if [[ -z "$API_KEY" ]]; then
            error "File is empty: $INPUT_FILE" 3
        fi
        ;;

    positional)
        # Legacy mode - show deprecation warning
        show_deprecation_warning

        if [[ -z "$API_KEY" ]]; then
            error "API key cannot be empty" 3
        fi
        ;;

    *)
        error "Unknown input mode: $INPUT_MODE" 1
        ;;
esac

# Check if the key already exists in the keychain
if security find-generic-password -s "$SERVICE_NAME" &>/dev/null; then
    if [[ "$FORCE_UPDATE" == false ]]; then
        read -rp "API key '$SERVICE_NAME' already exists in keychain. Overwrite? (y/N): " confirm
        if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
            log_info "Operation cancelled. API key not updated."
            exit 0
        fi
    fi
    log_info "Updating existing API key for '$SERVICE_NAME'..."
else
    log_info "Creating new API key for '$SERVICE_NAME'..."
fi

# Store the API key in the keychain
if security add-generic-password \
    -a "$USER" \
    -s "$SERVICE_NAME" \
    -w "$API_KEY" \
    -U \
    2>/dev/null; then

    # Clear API key from memory immediately
    API_KEY=""

    # Success message
    log_success "Successfully stored API key for '$SERVICE_NAME' in keychain"
    log_info "To retrieve this key: get-api-key $SERVICE_NAME"

    # Additional security tip for interactive mode
    if [[ "$INPUT_MODE" == "interactive" ]]; then
        log_info "Command in history shows only: store-api-key $SERVICE_NAME (no secret)"
    fi
else
    API_KEY=""
    error "Failed to store API key in keychain" 4
fi
