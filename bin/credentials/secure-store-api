#!/bin/zsh

# secure-store-api - Securely store API keys without exposing credentials in shell history
#
# This script abstracts the process of storing API keys using credmatch and store-api-key
# while ensuring that sensitive information doesn't appear in the shell history.

# Disable history for this script
setopt histignore

printUsage() {
  echo "Usage: secure-store-api <key-name> <credential-id>"
  echo ""
  echo "Arguments:"
  echo "  key-name      Name of the API key (e.g., BRAVE_API_KEY)"
  echo "  credential-id ID of the credential in the credential store (e.g., hard-bard-guard)"
  echo ""
  echo "Example:"
  echo "  secure-store-api BRAVE_API_KEY hard-bard-guard"
  echo ""
  exit 1
}

# Handle help flag
if [[ "$1" == "-h" || "$1" == "--help" || "$1" == "help" ]]; then
  printUsage
fi

# Check if required arguments are provided
if [[ -z "$1" || -z "$2" ]]; then
  echo "Error: Missing required arguments."
  printUsage
fi

KEY_NAME="$1"
CREDENTIAL_ID="$2"

# Execute the command in a way that prevents it from appearing in history
# The space before the command ensures it won't be recorded in history in most shells
echo "Fetching and storing API key for $KEY_NAME..."

# The actual command with a leading space to avoid history recording
 API_VALUE=$(credmatch fetch "$CREDENTIAL_ID" "$KEY_NAME" 2>/dev/null)

# Check if credmatch was successful
if [[ $? -ne 0 || -z "$API_VALUE" ]]; then
  echo "Error: Failed to fetch credential. Please verify the credential ID and key name."
  exit 1
fi

# Store the API key using the existing store-api-key command
# Using eval with careful quoting to prevent injection issues
eval "store-api-key \"$KEY_NAME\" \"$API_VALUE\""
STORE_RESULT=$?

# Clear the sensitive variable
API_VALUE=""

# Check if store-api-key was successful
if [[ $STORE_RESULT -ne 0 ]]; then
  echo "Error: Failed to store API key."
  exit 1
fi

echo "Successfully stored API key for $KEY_NAME."
exit 0
