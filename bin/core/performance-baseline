#!/usr/bin/env bash
set -euo pipefail

# Performance baseline tracking and comparison utility

readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly PROJECT_ROOT="$(cd "${SCRIPT_DIR}/../.." && pwd)"
readonly BASELINE_FILE="${PROJECT_ROOT}/.performance-baselines.json"

# Colors
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m'

usage() {
    cat <<EOF
Usage: performance-baseline [COMMAND] [OPTIONS]

Commands:
    record              Record current performance metrics as baseline
    compare             Compare current performance against baseline
    update              Update baseline with new metrics
    show                Display current baseline metrics
    help                Show this help message

Options:
    --metric NAME       Specify metric name (zsh-startup, script-exec, lazy-load)
    --value MS          Performance value in milliseconds
    --threshold PCT     Acceptable degradation percentage (default: 10)

Examples:
    performance-baseline record --metric zsh-startup --value 450
    performance-baseline compare --metric zsh-startup --value 480
    performance-baseline show
    performance-baseline update --metric zsh-startup --value 420

EOF
}

# Initialize baseline file if it doesn't exist
init_baseline_file() {
    if [[ ! -f "${BASELINE_FILE}" ]]; then
        cat > "${BASELINE_FILE}" <<'EOF'
{
  "version": "1.0",
  "updated": "",
  "metrics": {
    "zsh-startup": {
      "baseline_ms": 0,
      "threshold_pct": 10,
      "last_measured": 0,
      "history": []
    },
    "script-execution": {
      "baseline_ms": 0,
      "threshold_pct": 15,
      "last_measured": 0,
      "history": []
    },
    "lazy-load-overhead": {
      "baseline_ms": 0,
      "threshold_pct": 20,
      "last_measured": 0,
      "history": []
    }
  }
}
EOF
    fi
}

# Record a metric baseline
record_metric() {
    local metric="${1}"
    local value="${2}"
    local timestamp
    timestamp="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"

    init_baseline_file

    # Update baseline using jq
    jq --arg metric "${metric}" \
       --arg value "${value}" \
       --arg timestamp "${timestamp}" \
       '.updated = $timestamp |
        .metrics[$metric].baseline_ms = ($value | tonumber) |
        .metrics[$metric].last_measured = ($value | tonumber) |
        .metrics[$metric].history += [{timestamp: $timestamp, value: ($value | tonumber)}]' \
       "${BASELINE_FILE}" > "${BASELINE_FILE}.tmp" && \
       mv "${BASELINE_FILE}.tmp" "${BASELINE_FILE}"

    echo -e "${GREEN}[OK]${NC} Recorded ${BLUE}${metric}${NC} baseline: ${value}ms"
}

# Compare current metric against baseline
compare_metric() {
    local metric="${1}"
    local current_value="${2}"
    local threshold="${3:-10}"

    init_baseline_file

    # Read baseline value
    local baseline_value
    baseline_value=$(jq -r ".metrics[\"${metric}\"].baseline_ms" "${BASELINE_FILE}")

    if [[ "${baseline_value}" == "0" ]] || [[ "${baseline_value}" == "null" ]]; then
        echo -e "${YELLOW}[WARNING]${NC}  No baseline for ${metric}. Record one first."
        return 1
    fi

    # Calculate difference
    local diff=$((current_value - baseline_value))
    local pct_change=$(awk "BEGIN {printf \"%.2f\", (${diff} / ${baseline_value}) * 100}")

    echo -e "\n${BLUE}Performance Comparison: ${metric}${NC}"
    echo -e "  Baseline:  ${baseline_value}ms"
    echo -e "  Current:   ${current_value}ms"
    echo -e "  Diff:      ${diff}ms (${pct_change}%)"

    # Check if within threshold
    if (( $(echo "${pct_change} > ${threshold}" | bc -l) )); then
        echo -e "  Status:    ${RED}[ERROR] REGRESSION${NC} (exceeds ${threshold}% threshold)"
        return 1
    elif (( $(echo "${pct_change} < -5" | bc -l) )); then
        echo -e "  Status:    ${GREEN}[OK] IMPROVEMENT${NC}"
        return 0
    else
        echo -e "  Status:    ${GREEN}[OK] STABLE${NC}"
        return 0
    fi
}

# Update baseline with new value
update_metric() {
    local metric="${1}"
    local value="${2}"

    echo -e "${YELLOW}Updating baseline for ${metric} to ${value}ms${NC}"
    record_metric "${metric}" "${value}"
}

# Show all baselines
show_baselines() {
    init_baseline_file

    echo -e "\n${BLUE}Current Performance Baselines${NC}"
    echo -e "════════════════════════════════════════"

    local metrics
    metrics=$(jq -r '.metrics | keys[]' "${BASELINE_FILE}")

    for metric in ${metrics}; do
        local baseline
        local last_measured
        baseline=$(jq -r ".metrics[\"${metric}\"].baseline_ms" "${BASELINE_FILE}")
        last_measured=$(jq -r ".metrics[\"${metric}\"].last_measured" "${BASELINE_FILE}")

        echo -e "\n${YELLOW}${metric}${NC}"
        echo -e "  Baseline:      ${baseline}ms"
        echo -e "  Last measured: ${last_measured}ms"
    done

    echo -e "\n"
}

# Main command dispatcher
main() {
    if [[ $# -eq 0 ]]; then
        usage
        exit 1
    fi

    local command="${1}"
    shift

    case "${command}" in
        record)
            local metric=""
            local value=""
            while [[ $# -gt 0 ]]; do
                case "${1}" in
                    --metric) metric="${2}"; shift 2 ;;
                    --value) value="${2}"; shift 2 ;;
                    *) echo "Unknown option: ${1}"; usage; exit 1 ;;
                esac
            done

            if [[ -z "${metric}" ]] || [[ -z "${value}" ]]; then
                echo "Error: --metric and --value are required"
                usage
                exit 1
            fi

            record_metric "${metric}" "${value}"
            ;;

        compare)
            local metric=""
            local value=""
            local threshold="10"
            while [[ $# -gt 0 ]]; do
                case "${1}" in
                    --metric) metric="${2}"; shift 2 ;;
                    --value) value="${2}"; shift 2 ;;
                    --threshold) threshold="${2}"; shift 2 ;;
                    *) echo "Unknown option: ${1}"; usage; exit 1 ;;
                esac
            done

            if [[ -z "${metric}" ]] || [[ -z "${value}" ]]; then
                echo "Error: --metric and --value are required"
                usage
                exit 1
            fi

            compare_metric "${metric}" "${value}" "${threshold}"
            ;;

        update)
            local metric=""
            local value=""
            while [[ $# -gt 0 ]]; do
                case "${1}" in
                    --metric) metric="${2}"; shift 2 ;;
                    --value) value="${2}"; shift 2 ;;
                    *) echo "Unknown option: ${1}"; usage; exit 1 ;;
                esac
            done

            if [[ -z "${metric}" ]] || [[ -z "${value}" ]]; then
                echo "Error: --metric and --value are required"
                usage
                exit 1
            fi

            update_metric "${metric}" "${value}"
            ;;

        show)
            show_baselines
            ;;

        help|--help|-h)
            usage
            ;;

        *)
            echo "Unknown command: ${command}"
            usage
            exit 1
            ;;
    esac
}

main "$@"
