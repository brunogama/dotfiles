#!/bin/bash

# Generic Video Compression Script using FFmpeg
# Compatible with all common video formats

set -euo pipefail  # Exit on error, undefined vars, pipe failures

# Default values
readonly DEFAULT_SCALE="720p"
readonly DEFAULT_QUALITY=75
readonly DEFAULT_PRESET="medium"
readonly DEFAULT_NORMALIZE_FPS=true
readonly DEFAULT_TARGET_FPS=24

# Function to display usage
usage() {
    cat << 'EOF'
Usage: compress-video.sh -i input_file [options]

Options:
  -i, --input FILE      Input video file (required)
  -o, --output FILE     Output video file (optional, auto-generated if not specified)
  -s, --scale SCALE     Target resolution: 480p, 720p, 1080p (default: 1080p)
  -q, --quality NUM     Quality level 1-100, higher is better (default: 75)
  -p, --preset PRESET   Encoding preset: ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow (default: medium)
  -f, --fps FPS         Target frame rate (default: 30)
  --no-normalize-fps    Disable frame rate normalization (keep original fps)
  -h, --help           Show this help message

Frame Rate Behavior:
  - By default, videos with fps > 30 are normalized to 30fps
  - Videos with fps ≤ 30 keep their original frame rate
  - Use --no-normalize-fps to always keep original frame rate
  - Use -f to set a custom target frame rate

Quality Guide:
  90-100: Excellent quality (CRF 18-21)
  75-89:  High quality (CRF 22-26)
  50-74:  Good quality (CRF 27-32)
  25-49:  Fair quality (CRF 33-40)
  1-24:   Low quality (CRF 41-51)

Examples:
  compress-video.sh -i video.mp4
  compress-video.sh -i video.avi -s 720p -q 85
  compress-video.sh -i video.mov -o compressed.mp4 -s 480p -q 60 -f 24
  compress-video.sh -i video.mkv --no-normalize-fps -q 80
EOF
}

# Function to validate video file
validate_video_file() {
    local file="$1"
    
    if ! ffprobe -v error -select_streams v:0 -show_entries stream=codec_type -of csv=p=0 "$file" 2>/dev/null | grep -q "video"; then
        echo "Error: '$file' is not a valid video file or has no video stream!" >&2
        exit 1
    fi
}

# Function to convert quality (1-100) to CRF (51-18)
# Higher quality number = lower CRF = better quality
quality_to_crf() {
    local quality="$1"
    
    # Clamp quality to valid range
    if (( quality < 1 )); then 
        quality=1
    elif (( quality > 100 )); then 
        quality=100
    fi
    
    # Map 1-100 to 51-18 (33 point range)
    local crf=$(( 51 - ((quality - 1) * 33 / 99) ))
    
    # Ensure CRF is within valid range
    if (( crf < 18 )); then
        crf=18
    elif (( crf > 51 )); then
        crf=51
    fi
    
    echo "$crf"
}

# Function to get quality description from CRF
get_quality_description() {
    local crf="$1"
    
    if (( crf <= 21 )); then
        echo "Excellent"
    elif (( crf <= 26 )); then
        echo "High"
    elif (( crf <= 32 )); then
        echo "Good"
    elif (( crf <= 40 )); then
        echo "Fair"
    else
        echo "Low"
    fi
}

# Function to get video frame rate
get_video_fps() {
    local file="$1"
    local fps
    
    # Try avg_frame_rate first, then r_frame_rate as fallback
    fps=$(ffprobe -v error -select_streams v:0 -show_entries stream=avg_frame_rate -of csv=p=0 "$file" 2>/dev/null || echo "0/0")
    
    if [[ "$fps" == "0/0" || -z "$fps" ]]; then
        fps=$(ffprobe -v error -select_streams v:0 -show_entries stream=r_frame_rate -of csv=p=0 "$file" 2>/dev/null || echo "30/1")
    fi
    
    # Convert fraction to integer
    local int_fps=30  # default fallback
    if [[ "$fps" =~ ^([0-9]+)/([0-9]+)$ ]]; then
        local numerator="${BASH_REMATCH[1]}"
        local denominator="${BASH_REMATCH[2]}"
        
        if (( denominator > 0 )); then
            int_fps=$(( numerator / denominator ))
            # Handle very low frame rates or calculation errors
            if (( int_fps <= 0 )); then
                int_fps=30
            fi
        fi
    elif [[ "$fps" =~ ^[0-9]+(\.[0-9]+)?$ ]]; then
        # Handle decimal fps (remove decimal part)
        int_fps="${fps%.*}"
        if (( int_fps <= 0 )); then
            int_fps=30
        fi
    fi
    
    echo "$int_fps"
}

# Function to determine target frame rate
determine_target_fps() {
    local input_fps="$1"
    local normalize_fps="$2"
    local target_fps="$3"
    
    if [[ "$normalize_fps" == "false" ]]; then
        echo "$input_fps"
        return
    fi
    
    if (( input_fps > target_fps )); then
        echo "$target_fps"
    else
        echo "$input_fps"
    fi
}

# Function to get resolution parameters
get_resolution() {
    case "$1" in
        "480p")
            echo "scale=-2:480"
            ;;
        "720p")
            echo "scale=-2:720"
            ;;
        "1080p")
            echo "scale=-2:1080"
            ;;
        *)
            echo "scale=-2:1080"  # Default to 1080p
            ;;
    esac
}

# Function to generate output filename
generate_output_filename() {
    local input_file="$1"
    local scale="$2"
    local quality="$3"
    local fps="$4"
    
    local basename filename
    basename=$(basename "$input_file")
    filename="${basename%.*}"
    
    echo "${filename}_compressed_${scale}_q${quality}_${fps}fps.mp4"
}

# Function to get audio codec
get_audio_codec() {
    local file="$1"
    ffprobe -v error -select_streams a:0 -show_entries stream=codec_name -of csv=p=0 "$file" 2>/dev/null | head -n1
}

# Function to check required tools
check_dependencies() {
    local missing_tools=()
    
    for tool in ffmpeg ffprobe; do
        if ! command -v "$tool" &>/dev/null; then
            missing_tools+=("$tool")
        fi
    done
    
    if (( ${#missing_tools[@]} > 0 )); then
        echo "Error: Missing required tools: ${missing_tools[*]}" >&2
        echo "Please install FFmpeg package." >&2
        exit 1
    fi
}

# Function to validate numeric input
validate_number() {
    local value="$1"
    local min="$2"
    local max="$3"
    local name="$4"
    
    if ! [[ "$value" =~ ^[0-9]+$ ]]; then
        echo "Error: $name must be a positive integer." >&2
        exit 1
    fi
    
    if (( value < min || value > max )); then
        echo "Error: $name must be between $min and $max." >&2
        exit 1
    fi
}

# Main function
main() {
    # Initialize variables
    local input_file=""
    local output_file=""
    local scale="$DEFAULT_SCALE"
    local quality="$DEFAULT_QUALITY"
    local preset="$DEFAULT_PRESET"
    local normalize_fps="$DEFAULT_NORMALIZE_FPS"
    local target_fps="$DEFAULT_TARGET_FPS"
    
    # Parse command line arguments
    while (( $# > 0 )); do
        case "$1" in
            -i|--input)
                if [[ -z "${2:-}" ]]; then
                    echo "Error: --input requires a value." >&2
                    exit 1
                fi
                input_file="$2"
                shift 2
                ;;
            -o|--output)
                if [[ -z "${2:-}" ]]; then
                    echo "Error: --output requires a value." >&2
                    exit 1
                fi
                output_file="$2"
                shift 2
                ;;
            -s|--scale)
                if [[ -z "${2:-}" ]]; then
                    echo "Error: --scale requires a value." >&2
                    exit 1
                fi
                scale="$2"
                shift 2
                ;;
            -q|--quality)
                if [[ -z "${2:-}" ]]; then
                    echo "Error: --quality requires a value." >&2
                    exit 1
                fi
                quality="$2"
                shift 2
                ;;
            -p|--preset)
                if [[ -z "${2:-}" ]]; then
                    echo "Error: --preset requires a value." >&2
                    exit 1
                fi
                preset="$2"
                shift 2
                ;;
            -f|--fps)
                if [[ -z "${2:-}" ]]; then
                    echo "Error: --fps requires a value." >&2
                    exit 1
                fi
                target_fps="$2"
                shift 2
                ;;
            --no-normalize-fps)
                normalize_fps="false"
                shift
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            --)
                shift
                break
                ;;
            -*)
                echo "Error: Unknown option '$1'" >&2
                usage >&2
                exit 1
                ;;
            *)
                echo "Error: Unexpected argument '$1'" >&2
                usage >&2
                exit 1
                ;;
        esac
    done
    
    # Validate required parameters
    if [[ -z "$input_file" ]]; then
        echo "Error: Input file is required!" >&2
        usage >&2
        exit 1
    fi
    
    # Check if input file exists
    if [[ ! -f "$input_file" ]]; then
        echo "Error: Input file '$input_file' does not exist!" >&2
        exit 1
    fi
    
    # Check dependencies
    check_dependencies
    
    # Validate video file
    validate_video_file "$input_file"
    
    # Validate parameters
    if [[ ! "$scale" =~ ^(480p|720p|1080p)$ ]]; then
        echo "Error: Invalid scale '$scale'. Use 480p, 720p, or 1080p." >&2
        exit 1
    fi
    
    validate_number "$quality" 1 100 "Quality"
    validate_number "$target_fps" 1 120 "Target FPS"
    
    # Get video information
    echo "Analyzing input video..."
    local input_fps final_fps crf quality_desc audio_codec
    input_fps=$(get_video_fps "$input_file")
    final_fps=$(determine_target_fps "$input_fps" "$normalize_fps" "$target_fps")
    
    # Convert quality to CRF
    crf=$(quality_to_crf "$quality")
    quality_desc=$(get_quality_description "$crf")
    
    # Generate output filename if not provided
    if [[ -z "$output_file" ]]; then
        output_file=$(generate_output_filename "$input_file" "$scale" "$quality" "$final_fps")
    fi
    
    # Get audio codec for smart handling
    audio_codec=$(get_audio_codec "$input_file")
    
    # Set audio options
    local audio_opts
    if [[ "$audio_codec" == "aac" ]]; then
        audio_opts="-c:a copy"
    else
        audio_opts="-c:a aac -b:a 128k"
    fi
    
    # Build video filters
    local resolution_filter video_filters
    resolution_filter=$(get_resolution "$scale")
    
    if (( input_fps != final_fps )); then
        video_filters="${resolution_filter},fps=${final_fps}"
    else
        video_filters="$resolution_filter"
    fi
    
    # Display compression settings
    cat << EOF
=== Video Compression Settings ===
Input file: $input_file
Output file: $output_file
Target resolution: $scale
Quality: $quality/100 ($quality_desc quality)
CRF value: $crf
Preset: $preset
Input frame rate: ${input_fps} fps
Output frame rate: ${final_fps} fps
Audio codec: ${audio_codec:-none}
Audio handling: ${audio_opts}
===================================
EOF
    
    # Run FFmpeg compression
    echo "Starting compression..."
    
    # Use array for ffmpeg command to handle spaces properly
    local ffmpeg_cmd=(
        ffmpeg -hide_banner -loglevel info
        -i "$input_file"
        -c:v libx264
        -crf "$crf"
        -preset "$preset"
        -vf "$video_filters"
        -movflags +faststart
        -y
        "$output_file"
    )
    
    # Add audio options to command array
    if [[ "$audio_opts" == "-c:a copy" ]]; then
        ffmpeg_cmd+=(-c:a copy)
    else
        ffmpeg_cmd+=(-c:a aac -b:a 128k)
    fi
    
    # Execute ffmpeg
    "${ffmpeg_cmd[@]}"
    
    # Check if compression was successful and show results
    if [[ -f "$output_file" ]]; then
        echo "=== Compression Complete ==="
        
        # Display file size comparison
        if command -v du &>/dev/null; then
            local input_size output_size input_bytes output_bytes
            input_size=$(du -h "$input_file" | cut -f1)
            output_size=$(du -h "$output_file" | cut -f1)
            echo "Original file size: $input_size"
            echo "Compressed file size: $output_size"
            
            # Calculate compression ratio
            input_bytes=$(du -b "$input_file" | cut -f1)
            output_bytes=$(du -b "$output_file" | cut -f1)
            if (( input_bytes > 0 )); then
                local ratio savings
                ratio=$(( output_bytes * 100 / input_bytes ))
                savings=$(( 100 - ratio ))
                echo "Compression ratio: ${ratio}% of original"
                echo "Space saved: ${savings}%"
            fi
        fi
        
        # Get actual output fps for verification
        local actual_output_fps
        actual_output_fps=$(get_video_fps "$output_file")
        
        echo "Quality used: $quality/100 ($quality_desc - CRF $crf)"
        echo "Frame rate: ${input_fps} fps → ${actual_output_fps} fps"
        echo "Output file: $output_file"
        echo "============================"
    else
        echo "Error: Compression failed - output file not created!" >&2
        exit 1
    fi
}

# Run main function with all arguments
main "$@"