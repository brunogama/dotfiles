#!/usr/bin/env bash
set -euo pipefail

# Shell Script Linting Dashboard
# Unified linting and quality metrics for all shell scripts

readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly PROJECT_ROOT="$(cd "${SCRIPT_DIR}/../.." && pwd)"
readonly METRICS_FILE="${PROJECT_ROOT}/tests/quality-metrics.json"

# Colors
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m'

usage() {
    cat <<EOF
Usage: lint-dashboard [COMMAND] [OPTIONS]

Commands:
    run                 Run linting on all shell scripts
    report              Generate detailed report
    summary             Show summary statistics
    trends              Show quality trends
    help                Show this help message

Options:
    --format FORMAT     Output format (text, json, html)
    --save-metrics      Save metrics to quality-metrics.json

Examples:
    lint-dashboard run
    lint-dashboard report --format html
    lint-dashboard summary

EOF
}

# Initialize metrics file
init_metrics() {
    if [[ ! -f "${METRICS_FILE}" ]]; then
        cat > "${METRICS_FILE}" <<'EOF'
{
  "version": "1.0",
  "history": []
}
EOF
    fi
}

# Run shellcheck on all scripts
run_linting() {
    local save_metrics="${1:-false}"

    echo -e "${BLUE}Running shellcheck on all shell scripts...${NC}\n"

    if ! command -v shellcheck &> /dev/null; then
        echo -e "${RED}[ERROR]${NC} shellcheck not installed"
        return 1
    fi

    local total_files=0
    local passed_files=0
    local failed_files=0
    local total_errors=0
    local total_warnings=0
    local total_info=0

    declare -A file_issues

    # Lint all shell scripts
    while IFS= read -r -d '' script; do
        # Skip non-shell files
        if ! head -1 "${script}" 2>/dev/null | grep -qE '^#!/.*(bash|sh)'; then
            continue
        fi

        ((total_files++))

        local rel_path="${script#${PROJECT_ROOT}/}"
        local output
        local exit_code=0

        output=$(shellcheck -f json "${script}" 2>&1) || exit_code=$?

        if (( exit_code == 0 )); then
            ((passed_files++))
            file_issues["${rel_path}"]=0
        else
            ((failed_files++))

            # Count issues by severity
            local errors warnings info
            errors=$(echo "${output}" | jq '[.[] | select(.level == "error")] | length' 2>/dev/null || echo 0)
            warnings=$(echo "${output}" | jq '[.[] | select(.level == "warning")] | length' 2>/dev/null || echo 0)
            info=$(echo "${output}" | jq '[.[] | select(.level == "info")] | length' 2>/dev/null || echo 0)

            total_errors=$((total_errors + errors))
            total_warnings=$((total_warnings + warnings))
            total_info=$((total_info + info))

            local issue_count=$((errors + warnings + info))
            file_issues["${rel_path}"]=${issue_count}
        fi
    done < <(find "${PROJECT_ROOT}/bin" -type f -print0 2>/dev/null || true)

    # Calculate quality score (0-100)
    local quality_score
    if (( total_files > 0 )); then
        quality_score=$(awk "BEGIN {printf \"%.1f\", (${passed_files} / ${total_files}) * 100}")
    else
        quality_score="0.0"
    fi

    # Display summary
    echo -e "${BLUE}═══════════════════════════════════════${NC}"
    echo -e "${BLUE}  Linting Summary${NC}"
    echo -e "${BLUE}═══════════════════════════════════════${NC}\n"

    echo -e "  Total files:    ${total_files}"
    echo -e "  Passed:         ${GREEN}${passed_files}${NC}"
    echo -e "  Failed:         ${RED}${failed_files}${NC}"
    echo -e "  Errors:         ${RED}${total_errors}${NC}"
    echo -e "  Warnings:       ${YELLOW}${total_warnings}${NC}"
    echo -e "  Info:           ${BLUE}${total_info}${NC}"
    echo -e "  Quality Score:  ${quality_score}%"

    # Top problematic files
    if (( failed_files > 0 )); then
        echo -e "\n${YELLOW}Top 10 Problematic Files:${NC}\n"

        for file in "${!file_issues[@]}"; do
            echo "${file_issues[$file]} ${file}"
        done | sort -rn | head -10 | while read -r count file; do
            echo -e "  ${file} (${count} issues)"
        done
    fi

    # Save metrics if requested
    if [[ "${save_metrics}" == "true" ]]; then
        save_metrics_to_file "${total_files}" "${passed_files}" "${failed_files}" \
            "${total_errors}" "${total_warnings}" "${total_info}" "${quality_score}"
    fi

    echo -e "\n${BLUE}═══════════════════════════════════════${NC}"

    return 0
}

# Save metrics to file
save_metrics_to_file() {
    local total_files="$1"
    local passed_files="$2"
    local failed_files="$3"
    local errors="$4"
    local warnings="$5"
    local info="$6"
    local quality_score="$7"

    init_metrics

    local timestamp
    timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    # Add new metric entry
    jq --arg timestamp "${timestamp}" \
       --arg total "${total_files}" \
       --arg passed "${passed_files}" \
       --arg failed "${failed_files}" \
       --arg errors "${errors}" \
       --arg warnings "${warnings}" \
       --arg info "${info}" \
       --arg score "${quality_score}" \
       '.history += [{
         timestamp: $timestamp,
         total_files: ($total | tonumber),
         passed_files: ($passed | tonumber),
         failed_files: ($failed | tonumber),
         errors: ($errors | tonumber),
         warnings: ($warnings | tonumber),
         info: ($info | tonumber),
         quality_score: ($score | tonumber)
       }]' \
       "${METRICS_FILE}" > "${METRICS_FILE}.tmp" && \
       mv "${METRICS_FILE}.tmp" "${METRICS_FILE}"

    echo -e "${GREEN}[OK]${NC} Metrics saved to ${METRICS_FILE}"
}

# Show quality trends
show_trends() {
    init_metrics

    echo -e "${BLUE}Quality Trends${NC}\n"

    local history_count
    history_count=$(jq -r '.history | length' "${METRICS_FILE}")

    if (( history_count == 0 )); then
        echo -e "${YELLOW}[WARNING]${NC}  No historical data available"
        return 0
    fi

    echo -e "Last 10 runs:\n"

    jq -r '.history[-10:] [] | "\(.timestamp)  Score: \(.quality_score)%  Errors: \(.errors)  Warnings: \(.warnings)"' \
        "${METRICS_FILE}"

    # Calculate trend
    if (( history_count >= 2 )); then
        local prev_score current_score
        prev_score=$(jq -r '.history[-2].quality_score' "${METRICS_FILE}")
        current_score=$(jq -r '.history[-1].quality_score' "${METRICS_FILE}")

        local trend
        trend=$(awk "BEGIN {printf \"%.1f\", ${current_score} - ${prev_score}}")

        echo -e "\nTrend: "
        if (( $(echo "${trend} > 0" | bc -l) )); then
            echo -e "${GREEN}↑ +${trend}% (Improving)${NC}"
        elif (( $(echo "${trend} < 0" | bc -l) )); then
            echo -e "${RED}↓ ${trend}% (Degrading)${NC}"
        else
            echo -e "${BLUE}-> Stable${NC}"
        fi
    fi
}

# Main command dispatcher
main() {
    if [[ $# -eq 0 ]]; then
        run_linting "false"
        exit $?
    fi

    local command="${1}"
    shift

    local format="text"
    local save_metrics="false"

    while [[ $# -gt 0 ]]; do
        case "${1}" in
            --format) format="${2}"; shift 2 ;;
            --save-metrics) save_metrics="true"; shift ;;
            *) echo "Unknown option: ${1}"; usage; exit 1 ;;
        esac
    done

    case "${command}" in
        run)
            run_linting "${save_metrics}"
            ;;
        report)
            run_linting "false"
            ;;
        summary)
            run_linting "false"
            ;;
        trends)
            show_trends
            ;;
        help|--help|-h)
            usage
            ;;
        *)
            echo "Unknown command: ${command}"
            usage
            exit 1
            ;;
    esac
}

main "$@"
