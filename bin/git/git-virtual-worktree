#!/usr/bin/env -S uv run --quiet --script
# /// script
# dependencies = [
#   "rich>=13.7.0",
#   "typer>=0.12.0",
# ]
# ///
"""Git Virtual Worktree Manager for Large Monorepos.

A tool for managing feature branches using shallow Git clones instead of worktrees.
Optimized for large repositories (>1GB) with minimal disk usage and fast setup.

Uses shallow clones (--depth 1) for isolated feature branches, providing:
- 10-50x faster setup than worktrees for large repos
- Minimal disk usage (only latest commit vs full history)
- Independent .git directory (no I/O contention)
- Same workflow as git-worktree

This script uses shared library modules from bin/lib/ and bin/git/lib/ for:
- Error handling and exit codes (lib.git_common)
- Git command wrapper (lib.git_operations)
- Repository validation (lib.git_validation)
- Metadata serialization (lib.git_metadata)

Dependencies:
  - git-smart-merge: Intelligent branch merge script (in bin/ or PATH)

Examples:
  git-virtual-worktree create my-feature
  git-virtual-worktree merge my-feature
  git-virtual-worktree cleanup my-feature
  git-virtual-worktree list
"""

from __future__ import annotations

import shutil
import sys
import tempfile
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Optional

# Add lib/ directories to path for imports
sys.path.insert(0, str(Path(__file__).parent / "lib"))  # For git/lib/
sys.path.insert(0, str(Path(__file__).parent.parent))  # For bin/lib/

# Import from shared libraries
from git_common import CLONE_TIMEOUT, ExitCode, console, error_exit
from git_metadata import BaseMetadata
from git_operations import Git, run_git_smart_merge
from git_validation import check_clean_working_tree, check_git_repo, check_not_detached_head

import typer
from rich.panel import Panel
from rich.prompt import Confirm
from rich.table import Table

app = typer.Typer(
    help="Git Virtual Worktree Manager for Large Monorepos",
    add_completion=False,
)


@dataclass
class VirtualWorktreeMetadata(BaseMetadata):
    """Metadata for a virtual worktree (shallow clone).

    Inherits from BaseMetadata with additional fields for virtual worktrees.
    """

    remote_url: str
    depth: int


class VirtualWorktreeManager:
    """Manager for virtual worktree (shallow clone) operations."""

    def __init__(self, slug: str) -> None:
        """Initialize virtual worktree manager.

        Args:
            slug: Feature slug identifier
        """
        self.slug = self._validate_slug(slug)
        self.parent_dir = Path.cwd().name
        self.virtual_worktree_dir = self._get_virtual_worktree_dir()
        self.feature_branch = f"feature/{slug}"
        self.metadata_file = self._get_metadata_file()

    @staticmethod
    def _validate_slug(slug: str) -> str:
        """Validate and return slug.

        Args:
            slug: Feature slug to validate

        Returns:
            Validated slug (normalized to lowercase)

        Raises:
            typer.BadParameter: If slug is invalid
        """
        if not slug:
            raise typer.BadParameter("Feature slug cannot be empty")

        # Normalize to lowercase for consistency
        slug = slug.lower()

        # Check for path traversal
        if ".." in slug or "/" in slug or "\\" in slug:
            raise typer.BadParameter(
                "Slug cannot contain path traversal characters (/, \\, ..)"
            )

        if not all(c.isalnum() or c in "-_" for c in slug):
            raise typer.BadParameter(
                "Slug can only contain letters, numbers, hyphens, and underscores"
            )

        if len(slug) > 100:
            raise typer.BadParameter("Slug is too long (max 100 characters)")

        return slug

    def _get_virtual_worktree_dir(self) -> Path:
        """Get virtual worktree directory path.

        Returns:
            Path to virtual worktree directory

        Raises:
            typer.BadParameter: If parent directory name is invalid
        """
        if " " in self.parent_dir:
            raise typer.BadParameter(
                f"Parent directory '{self.parent_dir}' contains spaces. "
                "Please rename or use a different location."
            )

        # Construct path and validate it stays within parent
        vw_path = (Path("..") / f"{self.parent_dir}-{self.slug}").resolve()
        expected_parent = Path.cwd().parent.resolve()

        if not vw_path.parent == expected_parent:
            raise typer.BadParameter(
                f"Invalid virtual worktree path: {vw_path} "
                "Path traversal detected."
            )

        return vw_path

    def _get_metadata_file(self) -> Path:
        """Get metadata file path."""
        git_dir = Git.get_git_dir()
        return git_dir / f"virtual-worktree-{self.slug}.json"

    def save_metadata(
        self, base_branch: str, remote_url: str, depth: int
    ) -> None:
        """Save virtual worktree metadata atomically.

        Args:
            base_branch: Base branch name
            remote_url: Remote repository URL
            depth: Clone depth
        """
        metadata = VirtualWorktreeMetadata(
            base_branch=base_branch,
            created_at=datetime.now().isoformat(),
            created_by=Git.get_user_name(),
            slug=self.slug,
            remote_url=remote_url,
            depth=depth,
        )

        # Write atomically using temp file + rename
        with tempfile.NamedTemporaryFile(
            mode="w",
            dir=self.metadata_file.parent,
            delete=False,
            suffix=".json.tmp",
        ) as tmp:
            tmp.write(metadata.to_json())
            tmp_path = Path(tmp.name)

        try:
            tmp_path.replace(self.metadata_file)
        except Exception:
            tmp_path.unlink(missing_ok=True)
            raise

    def load_metadata(self) -> Optional[VirtualWorktreeMetadata]:
        """Load virtual worktree metadata.

        Returns:
            Metadata if exists, None otherwise
        """
        if not self.metadata_file.exists():
            return None

        try:
            return VirtualWorktreeMetadata.from_json(self.metadata_file.read_text())
        except (ValueError, OSError) as e:
            console.print(
                f"[yellow]Warning: Failed to load metadata: {e}[/yellow]"
            )
            return None

    def remove_metadata(self) -> None:
        """Remove virtual worktree metadata."""
        self.metadata_file.unlink(missing_ok=True)


@app.command()
def create(
    slug: str = typer.Argument(..., help="Feature slug identifier"),
    depth: int = typer.Option(1, "--depth", help="Clone depth (default: 1 for shallow)"),
) -> None:
    """Create a new virtual worktree with shallow clone.

    Creates a shallow clone at ../<parent>-<slug> with branch feature/<slug>
    based on the current branch. Much faster than git worktree for large repos.
    """
    check_git_repo()
    check_not_detached_head()

    manager = VirtualWorktreeManager(slug)
    base_branch = Git.get_current_branch()

    # Check if virtual worktree path already exists
    if manager.virtual_worktree_dir.exists():
        error_exit(
            f"Virtual worktree directory already exists: {manager.virtual_worktree_dir}",
            ExitCode.WORKTREE_EXISTS,
        )

    # Get remote URL
    try:
        result = Git.run("config", "--get", "remote.origin.url")
        remote_url = result.stdout.strip()
    except Exception as e:
        error_exit(f"Failed to get remote URL: {e}", ExitCode.ERROR)

    console.print(
        Panel(
            f"[cyan]Creating virtual worktree (shallow clone)[/cyan]\n\n"
            f"  Base: [green]{base_branch}[/green]\n"
            f"  Branch: [green]{manager.feature_branch}[/green]\n"
            f"  Path: [dim]{manager.virtual_worktree_dir}[/dim]\n"
            f"  Depth: [yellow]{depth}[/yellow] (shallow clone)",
            title="Git Virtual Worktree",
            border_style="cyan",
        )
    )

    # Clone repository with depth
    try:
        Git.run(
            "clone",
            "--depth",
            str(depth),
            "--branch",
            base_branch,
            remote_url,
            str(manager.virtual_worktree_dir),
            timeout=CLONE_TIMEOUT,
        )
    except Exception as e:
        error_exit(f"Failed to clone repository: {e}", ExitCode.ERROR)

    # Create and checkout feature branch in the clone
    try:
        Git.run(
            "checkout",
            "-b",
            manager.feature_branch,
            cwd=manager.virtual_worktree_dir,
        )
    except Exception as e:
        # Cleanup on failure
        shutil.rmtree(manager.virtual_worktree_dir, ignore_errors=True)
        error_exit(f"Failed to create feature branch: {e}", ExitCode.ERROR)

    # Save metadata
    manager.save_metadata(base_branch, remote_url, depth)

    console.print(
        f"\n[green]Success![/green] Created virtual worktree at: [bold]{manager.virtual_worktree_dir}[/bold]\n"
        f"  cd {manager.virtual_worktree_dir}"
    )


@app.command()
def merge(
    slug: str = typer.Argument(..., help="Feature slug identifier"),
    dry_run: bool = typer.Option(False, "--dry-run", help="Preview merge strategy without executing"),
    force_rebase: bool = typer.Option(False, "--force-rebase", help="Force rebase without conflict detection"),
    force_merge: bool = typer.Option(False, "--force-merge", help="Force merge without trying rebase"),
) -> None:
    """Merge virtual worktree feature branch using git-smart-merge.

    Returns to base branch and uses git-smart-merge to integrate the feature
    branch with intelligent rebase/merge strategy selection.
    """
    check_git_repo()
    check_not_detached_head()
    check_clean_working_tree()

    manager = VirtualWorktreeManager(slug)

    # Verify feature branch exists
    if not Git.branch_exists(manager.feature_branch):
        error_exit(
            f"Feature branch does not exist: {manager.feature_branch}",
            ExitCode.ERROR,
        )

    # Load metadata
    metadata = manager.load_metadata()
    if not metadata:
        console.print(
            f"[yellow]Warning:[/yellow] No metadata found for {slug}. "
            "Proceeding with merge..."
        )
        base_branch = Git.get_current_branch()
    else:
        base_branch = metadata.base_branch

    current_branch = Git.get_current_branch()

    # Checkout base branch if needed
    if current_branch != base_branch:
        console.print(f"[dim]Switching to base branch: {base_branch}[/dim]")
        Git.run("checkout", base_branch)

    console.print(
        Panel(
            f"[cyan]Merging feature branch[/cyan]\n\n"
            f"  Feature: [green]{manager.feature_branch}[/green]\n"
            f"  Into: [green]{base_branch}[/green]\n"
            f"  Strategy: [yellow]auto-detect (git-smart-merge)[/yellow]",
            title="Git Smart Merge",
            border_style="cyan",
        )
    )

    # Run git-smart-merge
    exit_code = run_git_smart_merge(
        manager.feature_branch,
        force_rebase=force_rebase,
        force_merge=force_merge,
        dry_run=dry_run,
    )

    if exit_code != 0:
        console.print(
            f"\n[red]Merge failed with exit code {exit_code}[/red]\n"
            "The feature branch has NOT been deleted or cleaned up."
        )
        raise typer.Exit(code=exit_code)

    if not dry_run:
        console.print(
            f"\n[green]Success![/green] Feature branch merged: {manager.feature_branch}"
        )


@app.command()
def cleanup(slug: str = typer.Argument(..., help="Feature slug identifier")) -> None:
    """Clean up virtual worktree and feature branch.

    Removes the virtual worktree directory, deletes the feature branch,
    and cleans up metadata. Use after successfully merging the feature.
    """
    check_git_repo()

    manager = VirtualWorktreeManager(slug)

    # Check if feature branch exists
    if not Git.branch_exists(manager.feature_branch):
        console.print(
            f"[yellow]Warning:[/yellow] Feature branch does not exist: {manager.feature_branch}"
        )
        branch_exists = False
    else:
        branch_exists = True

    # Check if virtual worktree exists
    if not manager.virtual_worktree_dir.exists():
        console.print(
            f"[yellow]Warning:[/yellow] Virtual worktree directory does not exist: {manager.virtual_worktree_dir}"
        )
        vw_exists = False
    else:
        vw_exists = True

    if not branch_exists and not vw_exists:
        console.print(
            "[yellow]Nothing to clean up. Branch and virtual worktree already removed.[/yellow]"
        )
        manager.remove_metadata()
        return

    # Show what will be cleaned up
    console.print(
        Panel(
            f"[yellow]The following will be removed:[/yellow]\n\n"
            f"  {'Branch:           [green]' + manager.feature_branch + '[/green]' if branch_exists else '[dim]Branch: (already removed)[/dim]'}\n"
            f"  {'Virtual Worktree: [green]' + str(manager.virtual_worktree_dir) + '[/green]' if vw_exists else '[dim]Virtual Worktree: (already removed)[/dim]'}",
            title="Cleanup Virtual Worktree",
            border_style="yellow",
        )
    )

    if not Confirm.ask("Proceed with cleanup?", default=False):
        console.print("[dim]Cleanup cancelled.[/dim]")
        return

    # Remove virtual worktree directory
    if vw_exists:
        try:
            shutil.rmtree(manager.virtual_worktree_dir)
            console.print(
                f"[green]Removed virtual worktree:[/green] {manager.virtual_worktree_dir}"
            )
        except Exception as e:
            console.print(
                f"[yellow]Warning: Failed to remove virtual worktree: {e}[/yellow]\n"
                "You may need to remove it manually."
            )

    # Delete branch
    if branch_exists:
        try:
            Git.run("branch", "-D", manager.feature_branch)
            console.print(f"[green]Deleted branch:[/green] {manager.feature_branch}")
        except Exception as e:
            console.print(
                f"[yellow]Warning: Failed to delete branch: {e}[/yellow]\n"
                "You may need to delete it manually."
            )

    # Remove metadata
    manager.remove_metadata()

    console.print("\n[green]Cleanup complete![/green]")


@app.command()
def list_virtual_worktrees() -> None:
    """List all virtual worktrees with metadata."""
    check_git_repo()

    git_dir = Git.get_git_dir()

    # Find all virtual worktree metadata files
    metadata_files = list(git_dir.glob("virtual-worktree-*.json"))

    if not metadata_files:
        console.print("[dim]No virtual worktrees found.[/dim]")
        return

    table = Table(
        title="Git Virtual Worktrees", show_header=True, header_style="bold cyan"
    )
    table.add_column("Slug", style="yellow")
    table.add_column("Base Branch", style="green")
    table.add_column("Path", style="dim")
    table.add_column("Status", style="cyan")

    for metadata_file in sorted(metadata_files):
        try:
            metadata = VirtualWorktreeMetadata.from_json(metadata_file.read_text())
            manager = VirtualWorktreeManager(metadata.slug)

            # Check status
            exists = manager.virtual_worktree_dir.exists()
            status = "[green]Active[/green]" if exists else "[red]Missing[/red]"

            table.add_row(
                metadata.slug,
                metadata.base_branch,
                str(manager.virtual_worktree_dir),
                status,
            )
        except Exception as e:
            console.print(
                f"[yellow]Warning: Failed to load metadata from {metadata_file}: {e}[/yellow]"
            )

    console.print(table)


@app.command()
def status(slug: str = typer.Argument(..., help="Feature slug identifier")) -> None:
    """Show status of a virtual worktree feature."""
    check_git_repo()

    manager = VirtualWorktreeManager(slug)
    metadata = manager.load_metadata()

    if not metadata:
        console.print(
            f"[yellow]No metadata found for feature: {slug}[/yellow]\n"
            "The feature may not have been created with this tool."
        )
        return

    # Check current state
    branch_exists = Git.branch_exists(manager.feature_branch)
    vw_exists = manager.virtual_worktree_dir.exists()

    status_icon = (
        "[green]●[/green]" if branch_exists and vw_exists else "[red]●[/red]"
    )

    console.print(
        Panel(
            f"{status_icon} [bold]{slug}[/bold]\n\n"
            f"  Base: [green]{metadata.base_branch}[/green]\n"
            f"  Branch: {'[green]' + manager.feature_branch + '[/green]' if branch_exists else '[red]' + manager.feature_branch + ' (missing)[/red]'}\n"
            f"  Path: {'[green]' + str(manager.virtual_worktree_dir) + '[/green]' if vw_exists else '[red]' + str(manager.virtual_worktree_dir) + ' (missing)[/red]'}\n"
            f"  Remote: [dim]{metadata.remote_url}[/dim]\n"
            f"  Depth: [dim]{metadata.depth}[/dim]\n"
            f"  Created: [dim]{metadata.created_at}[/dim]\n"
            f"  By: [dim]{metadata.created_by}[/dim]",
            title="Virtual Worktree Status",
            border_style="cyan",
        )
    )


if __name__ == "__main__":
    app()
