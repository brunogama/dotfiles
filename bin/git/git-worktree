#!/usr/bin/env -S uv run --quiet --script
# /// script
# dependencies = [
#   "rich>=13.7.0",
#   "typer>=0.12.0",
# ]
# ///
"""Git Worktree Feature Branch Manager.

A tool for managing git worktrees with feature branches using a rebase workflow.
Provides safe creation, merging, and cleanup of feature branches in separate worktrees.

This script uses shared library modules from bin/lib/ and bin/git/lib/ for:
- Error handling and exit codes (lib.git_common)
- Git command wrapper (lib.git_operations)
- Repository validation (lib.git_validation)
- Metadata serialization (lib.git_metadata)

Dependencies:
  - git-smart-merge: Intelligent branch merge script (in bin/ or PATH)
"""

from __future__ import annotations

import os
import sys
import tempfile
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Optional

# Add lib/ directories to path for imports
# Resolve symlink to find actual source directory
script_path = os.path.dirname(os.path.abspath(os.path.realpath(__file__)))
sys.path.insert(0, os.path.join(script_path, "lib"))  # For git/lib/
sys.path.insert(0, os.path.dirname(script_path))  # For bin/lib/

# Import from shared libraries
from git_common import ExitCode, console, error_exit
from git_metadata import BaseMetadata
from git_operations import Git, run_git_smart_merge
from git_validation import check_clean_working_tree, check_git_repo, check_not_detached_head

import typer
from rich.panel import Panel
from rich.prompt import Confirm
from rich.table import Table

app = typer.Typer(
    help="Git Worktree Feature Branch Manager",
    add_completion=False,
)


@dataclass
class WorktreeMetadata(BaseMetadata):
    """Metadata for a worktree feature.

    Inherits from BaseMetadata with JSON serialization support.
    """

    pass  # No additional fields needed beyond base


class WorktreeManager:
    """Manager for git worktree operations."""

    def __init__(self, slug: str) -> None:
        """Initialize worktree manager.

        Args:
            slug: Feature slug identifier
        """
        self.slug = self._validate_slug(slug)
        self.parent_dir = Path.cwd().name
        self.worktree_dir = self._get_worktree_dir()
        self.feature_branch = f"feature/{slug}"
        self.metadata_file = self._get_metadata_file()

    @staticmethod
    def _validate_slug(slug: str) -> str:
        """Validate and return slug.

        Args:
            slug: Feature slug to validate

        Returns:
            Validated slug (normalized to lowercase)

        Raises:
            typer.BadParameter: If slug is invalid
        """
        if not slug:
            raise typer.BadParameter("Feature slug cannot be empty")

        # Normalize to lowercase for consistency
        slug = slug.lower()

        # Check for path traversal
        if ".." in slug or "/" in slug or "\\" in slug:
            raise typer.BadParameter(
                "Slug cannot contain path traversal characters (/, \\, ..)"
            )

        if not all(c.isalnum() or c in "-_" for c in slug):
            raise typer.BadParameter(
                "Slug can only contain letters, numbers, hyphens, and underscores"
            )

        if len(slug) > 100:
            raise typer.BadParameter("Slug is too long (max 100 characters)")

        return slug

    def _get_worktree_dir(self) -> Path:
        """Get worktree directory path.

        Returns:
            Path to worktree directory

        Raises:
            typer.BadParameter: If parent directory name is invalid
        """
        if " " in self.parent_dir:
            raise typer.BadParameter(
                f"Parent directory '{self.parent_dir}' contains spaces. "
                "Please rename or use a different location."
            )

        # Construct path and validate it stays within parent
        worktree_path = (Path("..") / f"{self.parent_dir}-{self.slug}").resolve()
        expected_parent = Path.cwd().parent.resolve()

        if not worktree_path.parent == expected_parent:
            raise typer.BadParameter(
                f"Invalid worktree path: {worktree_path} "
                "Path traversal detected."
            )

        return worktree_path

    def _get_metadata_file(self) -> Path:
        """Get metadata file path."""
        git_dir = Git.get_git_dir()
        return git_dir / f"worktree-feature-{self.slug}.json"

    def save_metadata(self, base_branch: str) -> None:
        """Save worktree metadata atomically.

        Args:
            base_branch: Base branch name
        """
        metadata = WorktreeMetadata(
            base_branch=base_branch,
            created_at=datetime.now().isoformat(),
            created_by=Git.get_user_name(),
            slug=self.slug,
        )

        # Write atomically using temp file + rename
        with tempfile.NamedTemporaryFile(
            mode="w",
            dir=self.metadata_file.parent,
            delete=False,
            suffix=".json.tmp",
        ) as tmp:
            tmp.write(metadata.to_json())
            tmp_path = Path(tmp.name)

        try:
            tmp_path.replace(self.metadata_file)
        except Exception:
            tmp_path.unlink(missing_ok=True)
            raise

    def load_metadata(self) -> Optional[WorktreeMetadata]:
        """Load worktree metadata.

        Returns:
            Metadata if exists, None otherwise
        """
        if not self.metadata_file.exists():
            return None

        try:
            return WorktreeMetadata.from_json(self.metadata_file.read_text())
        except (ValueError, OSError) as e:
            console.print(
                f"[yellow]Warning: Failed to load metadata: {e}[/yellow]"
            )
            return None

    def remove_metadata(self) -> None:
        """Remove worktree metadata."""
        self.metadata_file.unlink(missing_ok=True)


@app.command()
def create(slug: str = typer.Argument(..., help="Feature slug identifier")) -> None:
    """Create a new worktree with feature branch.

    Creates a worktree at ../<parent>-<slug> with branch feature/<slug>
    based on the current branch.
    """
    check_git_repo()
    check_not_detached_head()

    manager = WorktreeManager(slug)
    base_branch = Git.get_current_branch()

    # Check if worktree path already exists
    if manager.worktree_dir.exists():
        error_exit(
            f"Worktree directory already exists: {manager.worktree_dir}",
            ExitCode.WORKTREE_EXISTS,
        )

    # Check if feature branch already exists
    if Git.branch_exists(manager.feature_branch):
        error_exit(
            f"Branch already exists: {manager.feature_branch}\n"
            "Use 'git branch -d {manager.feature_branch}' to remove it first.",
            ExitCode.BRANCH_EXISTS,
        )

    # Check if branch is in use by another worktree
    if Git.is_branch_in_worktree(manager.feature_branch):
        error_exit(
            f"Branch is already checked out in another worktree: {manager.feature_branch}",
            ExitCode.BRANCH_IN_USE,
        )

    console.print(
        Panel(
            f"[cyan]Creating worktree[/cyan]\n\n"
            f"  Base: [green]{base_branch}[/green]\n"
            f"  Branch: [green]{manager.feature_branch}[/green]\n"
            f"  Path: [dim]{manager.worktree_dir}[/dim]",
            title="Git Worktree",
            border_style="cyan",
        )
    )

    # Create worktree with new branch
    try:
        Git.run(
            "worktree",
            "add",
            "-b",
            manager.feature_branch,
            str(manager.worktree_dir),
            base_branch,
        )
    except Exception as e:
        error_exit(f"Failed to create worktree: {e}", ExitCode.ERROR)

    # Save metadata
    manager.save_metadata(base_branch)

    # Initialize submodules if present
    if Git.has_submodules():
        console.print("[dim]Initializing submodules...[/dim]")
        Git.run("submodule", "update", "--init", "--recursive", cwd=manager.worktree_dir)

    console.print(
        f"\n[green]Success![/green] Created worktree at: [bold]{manager.worktree_dir}[/bold]\n"
        f"  cd {manager.worktree_dir}"
    )


@app.command()
def merge(
    slug: str = typer.Argument(..., help="Feature slug identifier"),
    dry_run: bool = typer.Option(False, "--dry-run", help="Preview merge strategy without executing"),
    force_rebase: bool = typer.Option(False, "--force-rebase", help="Force rebase without conflict detection"),
    force_merge: bool = typer.Option(False, "--force-merge", help="Force merge without trying rebase"),
) -> None:
    """Merge worktree feature branch using git-smart-merge.

    Returns to base branch and uses git-smart-merge to integrate the feature
    branch with intelligent rebase/merge strategy selection.
    """
    check_git_repo()
    check_not_detached_head()
    check_clean_working_tree()

    manager = WorktreeManager(slug)

    # Verify feature branch exists
    if not Git.branch_exists(manager.feature_branch):
        error_exit(
            f"Feature branch does not exist: {manager.feature_branch}",
            ExitCode.ERROR,
        )

    # Load metadata
    metadata = manager.load_metadata()
    if not metadata:
        console.print(
            f"[yellow]Warning:[/yellow] No metadata found for {slug}. "
            "Proceeding with merge..."
        )
        base_branch = Git.get_current_branch()
    else:
        base_branch = metadata.base_branch

    current_branch = Git.get_current_branch()

    # Checkout base branch if needed
    if current_branch != base_branch:
        console.print(f"[dim]Switching to base branch: {base_branch}[/dim]")
        Git.run("checkout", base_branch)

    console.print(
        Panel(
            f"[cyan]Merging feature branch[/cyan]\n\n"
            f"  Feature: [green]{manager.feature_branch}[/green]\n"
            f"  Into: [green]{base_branch}[/green]\n"
            f"  Strategy: [yellow]auto-detect (git-smart-merge)[/yellow]",
            title="Git Smart Merge",
            border_style="cyan",
        )
    )

    # Run git-smart-merge
    exit_code = run_git_smart_merge(
        manager.feature_branch,
        force_rebase=force_rebase,
        force_merge=force_merge,
        dry_run=dry_run,
    )

    if exit_code != 0:
        console.print(
            f"\n[red]Merge failed with exit code {exit_code}[/red]\n"
            "The feature branch has NOT been deleted or cleaned up."
        )
        raise typer.Exit(code=exit_code)

    if not dry_run:
        console.print(
            f"\n[green]Success![/green] Feature branch merged: {manager.feature_branch}"
        )


@app.command()
def cleanup(slug: str = typer.Argument(..., help="Feature slug identifier")) -> None:
    """Clean up worktree and feature branch.

    Removes the worktree, deletes the feature branch, and cleans up metadata.
    Use after successfully merging the feature.
    """
    check_git_repo()

    manager = WorktreeManager(slug)

    # Check if feature branch exists
    if not Git.branch_exists(manager.feature_branch):
        console.print(
            f"[yellow]Warning:[/yellow] Feature branch does not exist: {manager.feature_branch}"
        )
        branch_exists = False
    else:
        branch_exists = True

    # Check if worktree exists
    if not manager.worktree_dir.exists():
        console.print(
            f"[yellow]Warning:[/yellow] Worktree directory does not exist: {manager.worktree_dir}"
        )
        worktree_exists = False
    else:
        worktree_exists = True

    if not branch_exists and not worktree_exists:
        console.print(
            "[yellow]Nothing to clean up. Branch and worktree already removed.[/yellow]"
        )
        manager.remove_metadata()
        return

    # Show what will be cleaned up
    console.print(
        Panel(
            f"[yellow]The following will be removed:[/yellow]\n\n"
            f"  {'Branch:   [green]' + manager.feature_branch + '[/green]' if branch_exists else '[dim]Branch: (already removed)[/dim]'}\n"
            f"  {'Worktree: [green]' + str(manager.worktree_dir) + '[/green]' if worktree_exists else '[dim]Worktree: (already removed)[/dim]'}",
            title="Cleanup Worktree",
            border_style="yellow",
        )
    )

    if not Confirm.ask("Proceed with cleanup?", default=False):
        console.print("[dim]Cleanup cancelled.[/dim]")
        return

    # Remove worktree
    if worktree_exists:
        try:
            Git.run("worktree", "remove", str(manager.worktree_dir), "--force")
            console.print(f"[green]Removed worktree:[/green] {manager.worktree_dir}")
        except Exception as e:
            console.print(
                f"[yellow]Warning: Failed to remove worktree: {e}[/yellow]\n"
                "You may need to remove it manually."
            )

    # Delete branch
    if branch_exists:
        try:
            Git.run("branch", "-D", manager.feature_branch)
            console.print(f"[green]Deleted branch:[/green] {manager.feature_branch}")
        except Exception as e:
            console.print(
                f"[yellow]Warning: Failed to delete branch: {e}[/yellow]\n"
                "You may need to delete it manually."
            )

    # Remove metadata
    manager.remove_metadata()

    console.print("\n[green]Cleanup complete![/green]")


@app.command()
def list_worktrees() -> None:
    """List all git worktrees with metadata."""
    check_git_repo()

    result = Git.run("worktree", "list", "--porcelain")

    # Parse worktree list
    worktrees = []
    current_worktree = {}

    for line in result.stdout.splitlines():
        if line.startswith("worktree "):
            if current_worktree:
                worktrees.append(current_worktree)
            current_worktree = {"path": line.split(" ", 1)[1]}
        elif line.startswith("branch "):
            current_worktree["branch"] = line.split("/")[-1]
        elif line.startswith("HEAD "):
            current_worktree["head"] = line.split(" ", 1)[1][:8]

    if current_worktree:
        worktrees.append(current_worktree)

    if not worktrees:
        console.print("[dim]No worktrees found.[/dim]")
        return

    table = Table(title="Git Worktrees", show_header=True, header_style="bold cyan")
    table.add_column("Path", style="green")
    table.add_column("Branch", style="yellow")
    table.add_column("HEAD", style="dim")

    for wt in worktrees:
        table.add_row(
            wt.get("path", ""),
            wt.get("branch", ""),
            wt.get("head", ""),
        )

    console.print(table)


@app.command()
def status(slug: str = typer.Argument(..., help="Feature slug identifier")) -> None:
    """Show status of a worktree feature."""
    check_git_repo()

    manager = WorktreeManager(slug)
    metadata = manager.load_metadata()

    if not metadata:
        console.print(
            f"[yellow]No metadata found for feature: {slug}[/yellow]\n"
            "The feature may not have been created with this tool."
        )
        return

    # Check current state
    branch_exists = Git.branch_exists(manager.feature_branch)
    worktree_exists = manager.worktree_dir.exists()

    status_icon = "[green]●[/green]" if branch_exists and worktree_exists else "[red]●[/red]"

    console.print(
        Panel(
            f"{status_icon} [bold]{slug}[/bold]\n\n"
            f"  Base: [green]{metadata.base_branch}[/green]\n"
            f"  Branch: {'[green]' + manager.feature_branch + '[/green]' if branch_exists else '[red]' + manager.feature_branch + ' (missing)[/red]'}\n"
            f"  Path: {'[green]' + str(manager.worktree_dir) + '[/green]' if worktree_exists else '[red]' + str(manager.worktree_dir) + ' (missing)[/red]'}\n"
            f"  Created: [dim]{metadata.created_at}[/dim]\n"
            f"  By: [dim]{metadata.created_by}[/dim]",
            title="Worktree Status",
            border_style="cyan",
        )
    )


if __name__ == "__main__":
    app()
