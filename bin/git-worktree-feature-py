#!/usr/bin/env -S uv run --quiet --script
# /// script
# dependencies = [
#   "rich>=13.7.0",
#   "typer>=0.12.0",
# ]
# ///
"""Git Worktree Feature Branch Manager.

A tool for managing git worktrees with feature branches using a rebase workflow.
Provides safe creation, merging, and cleanup of feature branches in separate worktrees.
"""

from __future__ import annotations

import json
import subprocess
import tempfile
from dataclasses import asdict, dataclass
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import NoReturn, Optional

import typer
from rich.console import Console
from rich.panel import Panel
from rich.prompt import Confirm
from rich.table import Table

app = typer.Typer(
    help="Git Worktree Feature Branch Manager",
    add_completion=False,
)
console = Console()

# Git command timeout in seconds
GIT_TIMEOUT = 300


class ExitCode(Enum):
    """Exit codes for the application."""

    SUCCESS = 0
    ERROR = 1
    NOT_GIT_REPO = 2
    DETACHED_HEAD = 3
    DIRTY_WORKING_TREE = 4
    WORKTREE_EXISTS = 5
    BRANCH_EXISTS = 6
    BRANCH_IN_USE = 7
    INVALID_PATH = 8


@dataclass
class WorktreeMetadata:
    """Metadata for a worktree feature."""

    base_branch: str
    created_at: str
    created_by: str
    slug: str

    def to_json(self) -> str:
        """Serialize metadata to JSON."""
        return json.dumps(asdict(self), indent=2)

    @classmethod
    def from_json(cls, data: str) -> WorktreeMetadata:
        """Deserialize metadata from JSON."""
        try:
            parsed = json.loads(data)
            return cls(**parsed)
        except (json.JSONDecodeError, TypeError, KeyError) as e:
            raise ValueError(f"Invalid metadata format: {e}") from e


class GitError(Exception):
    """Base exception for git-related errors."""

    pass


class Git:
    """Git command wrapper with error handling."""

    @staticmethod
    def run(
        *args: str,
        check: bool = True,
        capture_output: bool = True,
        cwd: Optional[Path] = None,
        timeout: int = GIT_TIMEOUT,
    ) -> subprocess.CompletedProcess:
        """Run a git command with proper error handling."""
        try:
            result = subprocess.run(
                ["git", *args],
                capture_output=capture_output,
                text=True,
                check=check,
                cwd=cwd,
                timeout=timeout,
            )
            return result
        except subprocess.TimeoutExpired as e:
            raise GitError(f"Git command timed out after {timeout}s: git {' '.join(args)}") from e
        except subprocess.CalledProcessError as e:
            if capture_output:
                error_msg = e.stderr.strip() if e.stderr else str(e)
                raise GitError(f"Git command failed: {error_msg}") from e
            raise GitError(f"Git command failed: {e}") from e

    @staticmethod
    def is_repo() -> bool:
        """Check if current directory is a git repository."""
        try:
            Git.run("rev-parse", "--git-dir")
            return True
        except (GitError, subprocess.TimeoutExpired):
            return False

    @staticmethod
    def get_git_dir() -> Path:
        """Get the git directory path."""
        result = Git.run("rev-parse", "--git-dir")
        return Path(result.stdout.strip()).resolve()

    @staticmethod
    def is_detached_head() -> bool:
        """Check if in detached HEAD state."""
        try:
            Git.run("symbolic-ref", "-q", "HEAD")
            return False
        except GitError:
            return True

    @staticmethod
    def get_current_branch() -> str:
        """Get the current branch name."""
        result = Git.run("rev-parse", "--abbrev-ref", "HEAD")
        return result.stdout.strip()

    @staticmethod
    def has_uncommitted_changes(cwd: Optional[Path] = None) -> bool:
        """Check if there are uncommitted changes.

        Args:
            cwd: Directory to check (defaults to current directory)
        """
        try:
            Git.run("diff-index", "--quiet", "HEAD", "--", cwd=cwd)
            return False
        except GitError:
            return True

    @staticmethod
    def branch_exists(branch: str) -> bool:
        """Check if a branch exists."""
        try:
            Git.run("show-ref", "--verify", "--quiet", f"refs/heads/{branch}")
            return True
        except GitError:
            return False

    @staticmethod
    def remote_branch_exists(branch: str, remote: str = "origin") -> bool:
        """Check if a remote branch exists."""
        try:
            Git.run("rev-parse", "--verify", f"{remote}/{branch}")
            return True
        except GitError:
            return False

    @staticmethod
    def get_user_name() -> str:
        """Get git user name."""
        try:
            result = Git.run("config", "user.name")
            return result.stdout.strip()
        except GitError:
            return "unknown"

    @staticmethod
    def is_branch_in_worktree(branch: str) -> bool:
        """Check if a branch is checked out in any worktree."""
        result = Git.run("worktree", "list")
        return f"[{branch}]" in result.stdout

    @staticmethod
    def has_submodules() -> bool:
        """Check if repository has submodules."""
        return Path(".gitmodules").exists()


class WorktreeManager:
    """Manager for git worktree operations."""

    def __init__(self, slug: str) -> None:
        """Initialize worktree manager.

        Args:
            slug: Feature slug identifier
        """
        self.slug = self._validate_slug(slug)
        self.parent_dir = Path.cwd().name
        self.worktree_dir = self._get_worktree_dir()
        self.feature_branch = f"feature/{slug}"
        self.metadata_file = self._get_metadata_file()

    @staticmethod
    def _validate_slug(slug: str) -> str:
        """Validate and return slug.

        Args:
            slug: Feature slug to validate

        Returns:
            Validated slug (normalized to lowercase)

        Raises:
            typer.BadParameter: If slug is invalid
        """
        if not slug:
            raise typer.BadParameter("Feature slug cannot be empty")

        # Normalize to lowercase for consistency
        slug = slug.lower()

        # Check for path traversal
        if ".." in slug or "/" in slug or "\\" in slug:
            raise typer.BadParameter(
                "Slug cannot contain path traversal characters (/, \\, ..)"
            )

        if not all(c.isalnum() or c in "-_" for c in slug):
            raise typer.BadParameter(
                "Slug can only contain letters, numbers, hyphens, and underscores"
            )

        if len(slug) > 100:
            raise typer.BadParameter("Slug is too long (max 100 characters)")

        return slug

    def _get_worktree_dir(self) -> Path:
        """Get worktree directory path.

        Returns:
            Path to worktree directory

        Raises:
            typer.BadParameter: If parent directory name is invalid
        """
        if " " in self.parent_dir:
            raise typer.BadParameter(
                f"Parent directory '{self.parent_dir}' contains spaces. "
                "Please rename or use a different location."
            )

        # Construct path and validate it stays within parent
        worktree_path = (Path("..") / f"{self.parent_dir}-{self.slug}").resolve()
        expected_parent = Path.cwd().parent.resolve()

        if not worktree_path.parent == expected_parent:
            raise typer.BadParameter(
                f"Invalid worktree path: {worktree_path} "
                "Path traversal detected."
            )

        return worktree_path

    def _get_metadata_file(self) -> Path:
        """Get metadata file path."""
        git_dir = Git.get_git_dir()
        return git_dir / f"worktree-feature-{self.slug}.json"

    def save_metadata(self, base_branch: str) -> None:
        """Save worktree metadata atomically.

        Args:
            base_branch: Base branch name
        """
        metadata = WorktreeMetadata(
            base_branch=base_branch,
            created_at=datetime.now().isoformat(),
            created_by=Git.get_user_name(),
            slug=self.slug,
        )

        # Write atomically using temp file + rename
        with tempfile.NamedTemporaryFile(
            mode="w",
            dir=self.metadata_file.parent,
            delete=False,
            suffix=".json.tmp",
        ) as tmp:
            tmp.write(metadata.to_json())
            tmp_path = Path(tmp.name)

        try:
            tmp_path.replace(self.metadata_file)
        except Exception:
            tmp_path.unlink(missing_ok=True)
            raise

    def load_metadata(self) -> Optional[WorktreeMetadata]:
        """Load worktree metadata.

        Returns:
            Metadata if exists, None otherwise
        """
        if not self.metadata_file.exists():
            return None

        try:
            return WorktreeMetadata.from_json(self.metadata_file.read_text())
        except (ValueError, OSError) as e:
            console.print(
                f"[yellow]Warning: Failed to load metadata: {e}[/yellow]"
            )
            return None

    def remove_metadata(self) -> None:
        """Remove worktree metadata."""
        self.metadata_file.unlink(missing_ok=True)


def error_exit(message: str, exit_code: ExitCode = ExitCode.ERROR) -> NoReturn:
    """Print error message and exit.

    Args:
        message: Error message to display
        exit_code: Exit code to use
    """
    console.print(f"[red]Error:[/red] {message}")
    raise typer.Exit(code=exit_code.value)


def check_git_repo() -> None:
    """Verify we're in a git repository."""
    if not Git.is_repo():
        error_exit("Not a git repository", ExitCode.NOT_GIT_REPO)


def check_not_detached_head() -> None:
    """Verify we're not in detached HEAD state."""
    if Git.is_detached_head():
        error_exit(
            "You are in detached HEAD state. "
            "Please checkout a branch first:\n  git checkout main",
            ExitCode.DETACHED_HEAD,
        )


def check_clean_working_tree() -> None:
    """Verify working tree is clean."""
    if Git.has_uncommitted_changes():
        error_exit(
            "Working directory has uncommitted changes.\n"
            "Please commit or stash your changes first:\n"
            "  git stash push -m 'WIP before feature merge'",
            ExitCode.DIRTY_WORKING_TREE,
        )


@app.command()
def create(slug: str = typer.Argument(..., help="Feature slug identifier")) -> None:
    """Create a new worktree with feature branch.

    Creates a worktree at ../<parent>-<slug> with branch feature/<slug>
    based on the current branch.
    """
    check_git_repo()
    check_not_detached_head()

    manager = WorktreeManager(slug)
    base_branch = Git.get_current_branch()

    console.print(Panel.fit(
        f"[bold]Creating worktree for feature:[/bold] {slug}\n"
        f"[dim]Parent directory:[/dim] {manager.parent_dir}\n"
        f"[dim]Base branch:[/dim] {base_branch}\n"
        f"[dim]Feature branch:[/dim] {manager.feature_branch}\n"
        f"[dim]Worktree directory:[/dim] {manager.worktree_dir}",
        title="Worktree Creation",
        border_style="blue",
    ))

    # Use is_dir() to handle symlinks correctly
    if manager.worktree_dir.is_dir():
        error_exit(
            f"Directory already exists: {manager.worktree_dir}",
            ExitCode.WORKTREE_EXISTS,
        )

    if Git.branch_exists(manager.feature_branch):
        error_exit(
            f"Branch already exists: {manager.feature_branch}\n"
            "Use a different slug or delete the existing branch",
            ExitCode.BRANCH_EXISTS,
        )

    if Git.is_branch_in_worktree(manager.feature_branch):
        console.print("[yellow]Current worktrees:[/yellow]")
        Git.run("worktree", "list", capture_output=False)
        error_exit(
            f"Branch '{manager.feature_branch}' is already checked out in another worktree",
            ExitCode.BRANCH_IN_USE,
        )

    try:
        with console.status("[bold blue]Creating worktree..."):
            Git.run(
                "worktree",
                "add",
                str(manager.worktree_dir),
                "-b",
                manager.feature_branch,
                base_branch,
            )

        manager.save_metadata(base_branch)

        if Git.has_submodules():
            with console.status("[bold blue]Initializing submodules..."):
                try:
                    Git.run(
                        "submodule",
                        "update",
                        "--init",
                        "--recursive",
                        cwd=manager.worktree_dir,
                    )
                except GitError:
                    console.print("[yellow]Warning: Failed to initialize submodules[/yellow]")

        console.print("[green]✓[/green] Worktree created successfully!")
        console.print("\n[bold]Next steps:[/bold]")
        console.print(f"  cd {manager.worktree_dir}")
        console.print("  # Make your changes and commits")
        console.print("  cd -")
        console.print(f"  git-worktree-feature-py merge {slug}")

    except GitError as e:
        error_exit(f"Failed to create worktree: {e}")


@app.command()
def merge(slug: str = typer.Argument(..., help="Feature slug identifier")) -> None:
    """Merge feature branch back with rebase.

    Rebases the feature commits onto the updated base branch.
    """
    check_git_repo()
    check_not_detached_head()
    check_clean_working_tree()

    manager = WorktreeManager(slug)
    metadata = manager.load_metadata()

    if metadata:
        base_branch = metadata.base_branch
        console.print(f"[dim]Using base branch from metadata:[/dim] {base_branch}")

        # Validate base branch still exists
        if not Git.branch_exists(base_branch):
            console.print(
                f"[yellow]Warning: Base branch '{base_branch}' from metadata no longer exists[/yellow]"
            )
            base_branch = Git.get_current_branch()
            console.print(f"[yellow]Falling back to current branch:[/yellow] {base_branch}")
    else:
        base_branch = Git.get_current_branch()
        console.print(
            f"[yellow]No metadata found, using current branch:[/yellow] {base_branch}"
        )

    console.print(Panel.fit(
        f"[bold]Merging feature:[/bold] {slug}\n"
        f"[dim]Feature branch:[/dim] {manager.feature_branch}\n"
        f"[dim]Base branch:[/dim] {base_branch}",
        title="Feature Merge",
        border_style="blue",
    ))

    if not Git.branch_exists(manager.feature_branch):
        error_exit(f"Feature branch not found: {manager.feature_branch}")

    current_branch = Git.get_current_branch()
    if current_branch != base_branch:
        console.print(
            f"[yellow]Switching from '{current_branch}' to '{base_branch}'[/yellow]"
        )
        try:
            Git.run("checkout", base_branch)
        except GitError as e:
            error_exit(f"Failed to checkout base branch: {e}")

    try:
        with console.status("[bold blue]Fetching latest changes..."):
            Git.run("fetch", "origin", timeout=60)
    except GitError:
        console.print("[yellow]Warning: Failed to fetch from origin[/yellow]")

    if Git.remote_branch_exists(base_branch):
        try:
            with console.status(f"[bold blue]Updating base branch from origin/{base_branch}..."):
                Git.run("rebase", f"origin/{base_branch}")
        except GitError as e:
            error_exit(
                f"Failed to rebase base branch onto origin/{base_branch}\n"
                f"{e}\n\n"
                "Resolve conflicts and run: git rebase --continue"
            )
    else:
        console.print(f"[yellow]No remote branch found for: {base_branch}[/yellow]")

    try:
        with console.status("[bold blue]Rebasing feature commits..."):
            Git.run("rebase", manager.feature_branch)

        console.print(f"[green]✓[/green] Feature successfully rebased onto {base_branch}")
        console.print("\n[bold]Next steps:[/bold]")
        console.print(f"  git push origin {base_branch}  # Push merged changes")
        console.print(f"  git-worktree-feature-py cleanup {slug}  # Clean up worktree and branch")

    except GitError as e:
        error_exit(
            f"Rebase failed: {e}\n\n"
            "After resolving conflicts:\n"
            "  git rebase --continue\n"
            f"  git-worktree-feature-py cleanup {slug}"
        )


@app.command()
def cleanup(slug: str = typer.Argument(..., help="Feature slug identifier")) -> None:
    """Remove worktree and delete feature branch.

    Cleans up the worktree directory and removes the feature branch.
    """
    check_git_repo()

    manager = WorktreeManager(slug)

    console.print(Panel.fit(
        f"[bold]Cleaning up feature:[/bold] {slug}",
        title="Cleanup",
        border_style="blue",
    ))

    # Use is_dir() to handle symlinks and broken paths
    if manager.worktree_dir.is_dir():
        result = Git.run("worktree", "list")
        if str(manager.worktree_dir.resolve()) in result.stdout:
            try:
                # Check uncommitted changes IN THE WORKTREE, not current dir
                if Git.has_uncommitted_changes(cwd=manager.worktree_dir):
                    console.print("[yellow]⚠ Worktree has uncommitted changes![/yellow]")
                    if not Confirm.ask(
                        "Continue with removal? This will lose uncommitted work!",
                        default=False,
                    ):
                        console.print("[blue]Cleanup cancelled[/blue]")
                        return
            except GitError:
                pass

            try:
                Git.run("worktree", "remove", str(manager.worktree_dir))
                console.print("[green]✓[/green] Worktree removed")
            except GitError:
                console.print("[yellow]Failed to remove cleanly, forcing...[/yellow]")
                Git.run("worktree", "remove", "--force", str(manager.worktree_dir))
                console.print("[green]✓[/green] Worktree force removed")
        else:
            console.print("[yellow]Worktree not tracked by git, removing directory...[/yellow]")
            import shutil
            shutil.rmtree(manager.worktree_dir)
            console.print("[green]✓[/green] Directory removed")
    else:
        console.print(f"[yellow]Worktree directory not found:[/yellow] {manager.worktree_dir}")

    if Git.branch_exists(manager.feature_branch):
        try:
            Git.run("branch", "-d", manager.feature_branch)
            console.print("[green]✓[/green] Branch deleted successfully")
        except GitError:
            console.print("[yellow]Failed to delete branch (might have unmerged commits)[/yellow]")
            if Confirm.ask("Force delete branch?", default=False):
                Git.run("branch", "-D", manager.feature_branch)
                console.print("[green]✓[/green] Branch force deleted")
            else:
                console.print(f"[blue]Keeping branch:[/blue] {manager.feature_branch}")
    else:
        console.print(f"[yellow]Feature branch not found:[/yellow] {manager.feature_branch}")

    manager.remove_metadata()
    console.print("[green]✓[/green] Cleanup complete!")


@app.command(name="list")
def list_worktrees() -> None:
    """List all git worktrees."""
    check_git_repo()

    console.print("[bold]Git worktrees:[/bold]")
    Git.run("worktree", "list", capture_output=False)


@app.command()
def status(slug: str = typer.Argument(..., help="Feature slug identifier")) -> None:
    """Show status of a feature worktree."""
    check_git_repo()

    manager = WorktreeManager(slug)
    metadata = manager.load_metadata()

    table = Table(title=f"Feature Status: {slug}", show_header=False)
    table.add_column("Property", style="cyan")
    table.add_column("Value")

    if metadata:
        table.add_row("Base Branch", metadata.base_branch)
        table.add_row("Created At", metadata.created_at)
        table.add_row("Created By", metadata.created_by)

    table.add_row("Feature Branch", manager.feature_branch)
    table.add_row("Worktree Path", str(manager.worktree_dir))

    console.print(table)
    console.print()

    if manager.worktree_dir.is_dir():
        console.print("[green]✓[/green] Worktree exists")
        if (manager.worktree_dir / ".git").exists():
            console.print("\n[bold]Worktree status:[/bold]")
            Git.run("status", "--short", capture_output=False, cwd=manager.worktree_dir)
    else:
        console.print("[yellow]✗[/yellow] Worktree not found")

    console.print()

    if Git.branch_exists(manager.feature_branch):
        console.print("[green]✓[/green] Feature branch exists")

        base = metadata.base_branch if metadata else Git.get_current_branch()
        console.print(f"\n[bold]Commits ahead of {base}:[/bold]")
        try:
            Git.run(
                "log",
                f"{base}..{manager.feature_branch}",
                "--oneline",
                capture_output=False,
            )
        except GitError:
            console.print("  (none or branches diverged)")
    else:
        console.print("[yellow]✗[/yellow] Feature branch not found")


if __name__ == "__main__":
    app()
