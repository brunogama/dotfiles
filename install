#!/usr/bin/env bash
#
# install - One-command dotfiles installation
#
# Usage: ./install [OPTIONS]

set -euo pipefail

# Script metadata
readonly INSTALL_SCRIPT_VERSION="1.0.0"

# Colors
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly CYAN='\033[0;36m'
readonly NC='\033[0m' # No Color

# Flags
DRY_RUN=false
YES=false
SKIP_BREW=false
SKIP_PACKAGES=false
SKIP_LINKS=false
SCRIPTS_ONLY=false
VERBOSE=false

# Detect platform
PLATFORM="$(uname -s | tr '[:upper:]' '[:lower:]')"
case "$PLATFORM" in
    darwin) PLATFORM="darwin" ;;
    linux) PLATFORM="linux" ;;
    *) PLATFORM="unknown" ;;
esac

# Detect dotfiles root
DOTFILES_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Logging functions (ASCII-safe, no unicode/emoji)
log_info() {
    echo -e "${BLUE}[i]${NC} $*"
}

log_success() {
    echo -e "${GREEN}[+]${NC} $*"
}

log_warning() {
    echo -e "${YELLOW}[!]${NC} $*"
}

log_error() {
    echo -e "${RED}[x]${NC} $*"
}

log_phase() {
    echo ""
    echo -e "${CYAN}======================================${NC}"
    echo -e "${CYAN} $*${NC}"
    echo -e "${CYAN}======================================${NC}"
    echo ""
}

log_verbose() {
    if [[ "$VERBOSE" == "true" ]]; then
        log_info "$*"
    fi
}

# Show usage
usage() {
    cat << EOF
install v${INSTALL_SCRIPT_VERSION}
One-command dotfiles installation

USAGE:
    ./install [OPTIONS]

OPTIONS:
    --dry-run          Preview what would be done
    --yes              Non-interactive mode (assume yes)
    --skip-brew        Skip Homebrew installation/bundle
    --skip-packages    Skip package installation
    --skip-links       Skip symlink creation
    --scripts-only     Only link scripts to ~/local/bin (skip everything else)
    --verbose          Show detailed output
    --help             Show this help message

EXAMPLES:
    # Interactive installation
    ./install

    # Non-interactive (for CI)
    ./install --yes

    # Preview only
    ./install --dry-run

    # Only update scripts in ~/local/bin
    ./install --scripts-only

EXIT CODES:
    0    Success
    1    General error
    2    Prerequisites not met
    3    User cancelled

EOF
}

# Parse arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            --yes)
                YES=true
                shift
                ;;
            --skip-brew)
                SKIP_BREW=true
                shift
                ;;
            --skip-packages)
                SKIP_PACKAGES=true
                shift
                ;;
            --skip-links)
                SKIP_LINKS=true
                shift
                ;;
            --scripts-only)
                SCRIPTS_ONLY=true
                shift
                ;;
            --verbose)
                VERBOSE=true
                shift
                ;;
            --help|-h)
                usage
                exit 0
                ;;
            *)
                log_error "Unknown option: $1"
                usage
                exit 1
                ;;
        esac
    done
}

# Confirm action
confirm() {
    if [[ "$YES" == "true" ]]; then
        return 0
    fi

    local prompt="$1"
    echo -n "$prompt (y/n): "
    read -r response
    if [[ "$response" =~ ^[Yy]$ ]]; then
        return 0
    fi
    return 1
}

# Check if command exists
command_exists() {
    command -v "$1" &> /dev/null
}

# Phase 1: Pre-flight checks
phase_preflight() {
    log_phase "Phase 1: Pre-flight Checks"

    if [[ ! -d "$DOTFILES_ROOT/.git" ]] && [[ ! -f "$DOTFILES_ROOT/.git" ]]; then
        log_error "Not in a git repository"
        log_info "Run this from your dotfiles repository"
        exit 2
    fi
    log_success "Running in git repository"

    if ! command_exists git; then
        log_error "git is not installed"
        exit 2
    fi
    log_success "git is installed"

    log_info "Platform: $PLATFORM"
    log_info "Dotfiles root: $DOTFILES_ROOT"
}

# Phase 2: Homebrew setup (macOS)
phase_homebrew() {
    if [[ "$PLATFORM" != "darwin" ]]; then
        log_info "Skipping Homebrew (not on macOS)"
        return 0
    fi

    if [[ "$SKIP_BREW" == "true" ]]; then
        log_info "Skipping Homebrew (--skip-brew flag)"
        return 0
    fi

    log_phase "Phase 2: Homebrew Setup"

    if command_exists brew; then
        log_success "Homebrew is already installed"
        local brew_version
        brew_version=$(brew --version | head -1)
        log_info "$brew_version"
    else
        log_warning "Homebrew is not installed"

        if [[ "$DRY_RUN" == "true" ]]; then
            log_info "Would install Homebrew"
            return 0
        fi

        if confirm "Install Homebrew now?"; then
            log_info "Installing Homebrew..."
            /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
            log_success "Homebrew installed"
        else
            log_warning "Skipped Homebrew installation"
        fi
    fi
}

# Phase 3: Dependencies
phase_dependencies() {
    log_phase "Phase 3: Dependencies"

    # Check jq
    if command_exists jq; then
        log_success "jq is already installed ($(jq --version))"
    else
        log_warning "jq is not installed (required for symlink creation)"

        if [[ "$DRY_RUN" == "true" ]]; then
            log_info "Would install jq"
            return 0
        fi

        if [[ "$PLATFORM" == "darwin" ]]; then
            if command_exists brew; then
                log_info "Installing jq via Homebrew..."
                brew install jq
                log_success "jq installed"
            else
                log_error "Cannot install jq: Homebrew not available"
                exit 2
            fi
        else
            log_error "Please install jq manually:"
            log_info "  Ubuntu/Debian: sudo apt install jq"
            log_info "  CentOS/RHEL: sudo yum install jq"
            log_info "  Arch: sudo pacman -S jq"
            exit 2
        fi
    fi
}

# Phase 4: Homebrew bundle
phase_bundle() {
    if [[ "$PLATFORM" != "darwin" ]]; then
        log_info "Skipping Homebrew bundle (not on macOS)"
        return 0
    fi

    if [[ "$SKIP_BREW" == "true" ]] || [[ "$SKIP_PACKAGES" == "true" ]]; then
        log_info "Skipping Homebrew bundle (--skip-* flag)"
        return 0
    fi

    log_phase "Phase 4: Homebrew Bundle"

    local brewfile="$DOTFILES_ROOT/packages/homebrew/Brewfile"

    if [[ ! -f "$brewfile" ]]; then
        log_warning "Brewfile not found at: $brewfile"
        return 0
    fi

    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "Would run: brew bundle install --file=$brewfile"
        return 0
    fi

    if ! command_exists brew; then
        log_warning "Homebrew not installed, skipping bundle"
        return 0
    fi

    log_info "Installing packages from Brewfile..."
    if brew bundle install --file="$brewfile"; then
        log_success "Homebrew bundle completed"
    else
        log_warning "Some packages may have failed to install"
    fi
}

# Phase 4.5: Migrate ~/.local to ~/local
phase_migrate_local_directory() {
    log_phase "Phase 4.5: Directory Migration"

    local old_local="$HOME/.local"
    local new_local="$HOME/local"

    # Check if old .local directory exists
    if [[ ! -d "$old_local" ]]; then
        log_info "No ~/.local directory found - nothing to migrate"
        # Ensure new directory exists
        if [[ ! -d "$new_local" ]]; then
            mkdir -p "$new_local/bin"
            log_success "Created ~/local/bin directory"
        fi
        return 0
    fi

    log_warning "Found ~/.local directory"
    log_info "The dotfiles system now uses ~/local instead of ~/.local"
    echo ""
    echo "Migration options:"
    echo "  1. Rename ~/.local to ~/local (preserves all your existing scripts)"
    echo "  2. Create new ~/local and copy missing scripts (keeps both directories)"
    echo "  3. Skip migration (keep ~/.local as-is, may cause conflicts)"
    echo ""

    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "Would prompt for migration strategy"
        return 0
    fi

    local choice
    if [[ "$YES" == "true" ]]; then
        # Non-interactive: default to option 2 (safest)
        choice="2"
        log_info "Non-interactive mode: choosing option 2 (create new, copy missing)"
    else
        echo -n "Enter choice (1/2/3): "
        read -r choice
    fi

    case "$choice" in
        1)
            # Rename strategy
            if [[ -d "$new_local" ]]; then
                log_error "~/local already exists - cannot rename ~/.local"
                log_info "Please manually handle the conflict or choose option 2"
                return 1
            fi

            log_info "Renaming ~/.local to ~/local..."
            if mv "$old_local" "$new_local"; then
                log_success "Successfully renamed ~/.local to ~/local"
                log_info "All your existing scripts are now in ~/local/bin"
            else
                log_error "Failed to rename directory"
                return 1
            fi
            ;;

        2)
            # Copy missing strategy
            log_info "Creating ~/local directory structure..."
            mkdir -p "$new_local/bin"

            if [[ -d "$old_local/bin" ]]; then
                log_info "Checking for scripts to migrate from ~/.local/bin..."

                local copied_count=0
                local skipped_count=0

                for script in "$old_local/bin"/*; do
                    if [[ ! -f "$script" ]]; then
                        continue
                    fi

                    local script_name=$(basename "$script")
                    local new_script="$new_local/bin/$script_name"

                    # Check if script will be installed by dotfiles
                    local dotfiles_script="$DOTFILES_ROOT/bin/core/$script_name"
                    if [[ ! -f "$dotfiles_script" ]]; then
                        dotfiles_script="$DOTFILES_ROOT/bin/credentials/$script_name"
                    fi
                    if [[ ! -f "$dotfiles_script" ]]; then
                        dotfiles_script="$DOTFILES_ROOT/bin/git/$script_name"
                    fi
                    if [[ ! -f "$dotfiles_script" ]]; then
                        dotfiles_script="$DOTFILES_ROOT/bin/macos/$script_name"
                    fi

                    # Copy if not in dotfiles and not already in new location
                    if [[ ! -f "$dotfiles_script" ]] && [[ ! -f "$new_script" ]]; then
                        if cp "$script" "$new_script"; then
                            chmod +x "$new_script" 2>/dev/null || true
                            log_success "Copied: $script_name"
                            ((copied_count++)) || true
                        fi
                    else
                        ((skipped_count++)) || true
                    fi
                done

                if [[ $copied_count -gt 0 ]]; then
                    log_success "Migrated $copied_count custom script(s) to ~/local/bin"
                fi
                if [[ $skipped_count -gt 0 ]]; then
                    log_info "Skipped $skipped_count script(s) (will be installed by dotfiles)"
                fi

                echo ""
                log_info "Your ~/.local directory is still intact"
                log_warning "You can manually review and delete ~/.local when ready"
                log_info "Command: rm -rf ~/.local"
            else
                log_info "No ~/.local/bin directory found"
            fi

            log_success "Created ~/local directory with migrated scripts"
            ;;

        3)
            # Skip migration
            log_warning "Skipping migration - keeping ~/.local as-is"
            log_warning "Note: This may cause PATH conflicts"

            # Still create new directory if it doesn't exist
            if [[ ! -d "$new_local" ]]; then
                mkdir -p "$new_local/bin"
                log_success "Created ~/local/bin directory"
            fi
            ;;

        *)
            log_error "Invalid choice"
            return 1
            ;;
    esac
}

# Phase 5: Version Manager Setup (pyenv, rbenv, nvm, mise)
phase_version_managers() {
    log_phase "Phase 5: Version Manager Setup"

    # First, migrate away from Homebrew-managed runtimes
    phase_migrate_from_homebrew

    # Then install version managers
    phase_mise
    phase_pyenv
    phase_rbenv
    phase_nvm
}

# Phase 5-pre: Migrate from Homebrew-managed language runtimes
phase_migrate_from_homebrew() {
    log_info "Checking for Homebrew-managed language runtimes..."

    if ! command_exists brew; then
        log_info "Homebrew not installed, skipping migration check"
        return 0
    fi

    local brew_packages_to_remove=()
    local has_conflicts=false

    # Check for Homebrew Python
    if brew list python &>/dev/null || brew list python@3.11 &>/dev/null || brew list python@3.12 &>/dev/null; then
        brew_packages_to_remove+=("python" "python@3.11" "python@3.12" "python@3.10" "python@3.9")
        has_conflicts=true
        log_warning "Found Homebrew Python (conflicts with pyenv)"
    fi

    # Check for Homebrew Node
    if brew list node &>/dev/null || brew list node@20 &>/dev/null || brew list node@18 &>/dev/null; then
        brew_packages_to_remove+=("node" "node@20" "node@18" "node@16")
        has_conflicts=true
        log_warning "Found Homebrew Node.js (conflicts with nvm)"
    fi

    # Check for Homebrew Ruby
    if brew list ruby &>/dev/null || brew list ruby@3.1 &>/dev/null; then
        brew_packages_to_remove+=("ruby" "ruby@3.1" "ruby@3.0")
        has_conflicts=true
        log_warning "Found Homebrew Ruby (conflicts with rbenv)"
    fi

    # Check for Homebrew-installed version managers (we want git-cloned versions)
    if brew list pyenv &>/dev/null; then
        brew_packages_to_remove+=("pyenv" "pyenv-virtualenv")
        has_conflicts=true
        log_warning "Found Homebrew pyenv (will replace with git clone)"
    fi

    if brew list rbenv &>/dev/null; then
        brew_packages_to_remove+=("rbenv" "ruby-build")
        has_conflicts=true
        log_warning "Found Homebrew rbenv (will replace with git clone)"
    fi

    if brew list nvm &>/dev/null; then
        brew_packages_to_remove+=("nvm")
        has_conflicts=true
        log_warning "Found Homebrew nvm (will replace with official installer)"
    fi

    if [[ "$has_conflicts" != "true" ]]; then
        log_success "No Homebrew language runtimes found - clean slate"
        return 0
    fi

    echo ""
    log_warning "Homebrew-managed language runtimes can conflict with version managers."
    log_info "Recommended: Uninstall them and use pyenv/rbenv/nvm instead."
    echo ""
    echo "Packages to remove:"
    for pkg in "${brew_packages_to_remove[@]}"; do
        echo "  - $pkg"
    done
    echo ""

    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "Would uninstall: ${brew_packages_to_remove[*]}"
        return 0
    fi

    if ! confirm "Uninstall these Homebrew packages to avoid conflicts?"; then
        log_warning "Skipped Homebrew cleanup - you may experience conflicts"
        log_info "To manually clean up later: brew uninstall --ignore-dependencies <package>"
        return 0
    fi

    log_info "Uninstalling Homebrew language runtimes..."

    for pkg in "${brew_packages_to_remove[@]}"; do
        if brew list "$pkg" &>/dev/null; then
            log_info "Uninstalling $pkg..."
            if brew uninstall --ignore-dependencies "$pkg" 2>/dev/null; then
                log_success "Uninstalled $pkg"
            else
                log_warning "Could not uninstall $pkg (may not be installed)"
            fi
        fi
    done

    # Clean up any leftover node_modules from global npm
    if [[ -d "/usr/local/lib/node_modules" ]]; then
        log_info "Cleaning up global node_modules..."
        sudo rm -rf /usr/local/lib/node_modules 2>/dev/null || true
    fi

    # Remove Homebrew's shims from PATH for this session
    # This prevents conflicts during version manager installation
    local cleaned_path
    cleaned_path=$(echo "$PATH" | tr ':' '\n' | grep -v '/usr/local/opt/python' | grep -v '/usr/local/opt/node' | grep -v '/usr/local/opt/ruby' | tr '\n' ':' | sed 's/:$//')
    export PATH="$cleaned_path"

    log_success "Homebrew language runtimes removed"
    log_info "Version managers will be installed next"
}

# Phase 5a: mise (polyglot version manager - optional)
phase_mise() {
    log_info "Setting up mise (polyglot version manager)..."

    # Check if mise is already installed
    if command_exists mise; then
        log_success "mise is already installed ($(mise --version))"
        return 0
    fi

    # Check if user wants mise
    log_info "mise can manage Python, Node, Ruby, and 100+ other tools"
    log_info "It's optional - you can use pyenv/rbenv/nvm individually instead"

    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "Would install mise via official installer"
        return 0
    fi

    if ! confirm "Install mise (optional polyglot version manager)?"; then
        log_info "Skipped mise - will use individual version managers"
        return 0
    fi

    log_info "Installing mise..."
    if curl https://mise.run | sh; then
        log_success "mise installed"

        # Add mise to PATH for this session
        export PATH="$HOME/local/bin:$PATH"

        # Verify installation
        if command_exists mise; then
            log_info "Verified: mise $(mise --version)"
            log_info "mise will be lazy-loaded in your shell"
        fi
    else
        log_warning "Failed to install mise (non-critical)"
    fi
}

# Phase 5b: pyenv (Python version manager)
phase_pyenv() {
    log_info "Setting up pyenv (Python version manager)..."

    local pyenv_root="$HOME/.pyenv"

    # Check if pyenv is properly installed (has libexec directory with pyenv executable)
    if [[ -d "$pyenv_root" ]] && [[ -f "$pyenv_root/libexec/pyenv" ]]; then
        log_success "pyenv is already installed"

        # Add to PATH and initialize for this session
        export PYENV_ROOT="$pyenv_root"
        export PATH="$PYENV_ROOT/bin:$PATH"
        eval "$(pyenv init -)"

        # Check if any Python version is installed
        if pyenv versions --bare 2>/dev/null | grep -q .; then
            local current_python
            current_python=$(pyenv version 2>/dev/null | cut -d' ' -f1)
            log_info "Python versions: $(pyenv versions --bare | tr '\n' ' ')"
            log_success "Current global Python: $current_python"
        else
            log_warning "No Python versions installed via pyenv"
            if [[ "$DRY_RUN" != "true" ]] && confirm "Install latest Python version?"; then
                local latest_python
                latest_python=$(pyenv install --list 2>/dev/null | grep -E '^\s*[0-9]+\.[0-9]+\.[0-9]+$' | tail -1 | tr -d ' ')
                if [[ -n "$latest_python" ]]; then
                    log_info "Installing Python $latest_python..."
                    if pyenv install "$latest_python" && pyenv global "$latest_python"; then
                        log_success "Python $latest_python installed and set as default"
                    fi
                fi
            fi
        fi
        return 0
    fi

    # Remove incomplete installation if it exists
    if [[ -d "$pyenv_root" ]]; then
        log_warning "Found incomplete pyenv installation, removing..."
        rm -rf "$pyenv_root"
    fi

    log_warning "pyenv is not installed"

    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "Would install pyenv from GitHub (git clone)"
        log_info "Would install latest stable Python version"
        return 0
    fi

    if ! confirm "Install pyenv (Python version manager)?"; then
        log_warning "Skipped pyenv installation"
        return 0
    fi

    log_info "Installing pyenv via git clone..."
    if git clone https://github.com/pyenv/pyenv.git "$pyenv_root"; then
        log_success "pyenv cloned to $pyenv_root"
    else
        log_error "Failed to clone pyenv"
        return 1
    fi

    # Add pyenv to PATH for this session
    export PYENV_ROOT="$pyenv_root"
    export PATH="$PYENV_ROOT/bin:$PATH"
    eval "$(pyenv init -)"

    log_info "Installing latest stable Python version..."
    local latest_python
    latest_python=$(pyenv install --list 2>/dev/null | grep -E '^\s*[0-9]+\.[0-9]+\.[0-9]+$' | tail -1 | tr -d ' ')

    if [[ -z "$latest_python" ]]; then
        log_warning "Could not determine latest Python version"
        return 0
    fi

    log_info "Installing Python $latest_python (this may take a few minutes)..."
    if pyenv install "$latest_python" && pyenv global "$latest_python"; then
        log_success "Python $latest_python installed and set as global default"
        pyenv rehash
        log_info "Verified: $(pyenv version)"
    else
        log_warning "Failed to install Python version"
    fi
}

# Phase 5c: rbenv (Ruby version manager)
phase_rbenv() {
    log_info "Setting up rbenv (Ruby version manager)..."

    local rbenv_root="$HOME/.rbenv"

    # Check if rbenv is properly installed (has libexec directory with rbenv executable)
    if [[ -d "$rbenv_root" ]] && [[ -f "$rbenv_root/libexec/rbenv" ]]; then
        log_success "rbenv is already installed"

        # Add to PATH and initialize for this session
        export PATH="$rbenv_root/bin:$PATH"
        eval "$(rbenv init - bash)"

        # Check if any Ruby version is installed
        if rbenv versions --bare 2>/dev/null | grep -q .; then
            local current_ruby
            current_ruby=$(rbenv version 2>/dev/null | cut -d' ' -f1)
            log_info "Ruby versions: $(rbenv versions --bare | tr '\n' ' ')"
            log_success "Current global Ruby: $current_ruby"
        else
            log_warning "No Ruby versions installed via rbenv"
            if [[ "$DRY_RUN" != "true" ]] && confirm "Install latest Ruby version?"; then
                # Ensure ruby-build plugin exists
                if [[ ! -d "$rbenv_root/plugins/ruby-build" ]]; then
                    log_info "Installing ruby-build plugin..."
                    git clone https://github.com/rbenv/ruby-build.git "$rbenv_root/plugins/ruby-build"
                fi

                local latest_ruby
                latest_ruby=$(rbenv install --list 2>/dev/null | grep -E '^\s*[0-9]+\.[0-9]+\.[0-9]+$' | tail -1 | tr -d ' ')
                if [[ -n "$latest_ruby" ]]; then
                    log_info "Installing Ruby $latest_ruby..."
                    if rbenv install "$latest_ruby" && rbenv global "$latest_ruby"; then
                        log_success "Ruby $latest_ruby installed and set as default"
                        gem install bundler && rbenv rehash
                    fi
                fi
            fi
        fi
        return 0
    fi

    # Remove incomplete installation if it exists
    if [[ -d "$rbenv_root" ]]; then
        log_warning "Found incomplete rbenv installation, removing..."
        rm -rf "$rbenv_root"
    fi

    log_warning "rbenv is not installed"

    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "Would install rbenv from GitHub (git clone)"
        log_info "Would install ruby-build plugin"
        log_info "Would install latest stable Ruby version"
        return 0
    fi

    if ! confirm "Install rbenv (Ruby version manager)?"; then
        log_warning "Skipped rbenv installation"
        return 0
    fi

    log_info "Installing rbenv via git clone..."
    if git clone https://github.com/rbenv/rbenv.git "$rbenv_root"; then
        log_success "rbenv cloned to $rbenv_root"
    else
        log_error "Failed to clone rbenv"
        return 1
    fi

    log_info "Installing ruby-build plugin for rbenv..."
    if git clone https://github.com/rbenv/ruby-build.git "$rbenv_root/plugins/ruby-build"; then
        log_success "ruby-build plugin installed"
    else
        log_warning "Failed to install ruby-build plugin (non-fatal)"
    fi

    # Add rbenv to PATH for this session
    export PATH="$rbenv_root/bin:$PATH"
    eval "$(rbenv init - bash)"

    log_info "Installing latest stable Ruby version..."
    local latest_ruby
    latest_ruby=$(rbenv install --list 2>/dev/null | grep -E '^\s*[0-9]+\.[0-9]+\.[0-9]+$' | tail -1 | tr -d ' ')

    if [[ -z "$latest_ruby" ]]; then
        log_warning "Could not determine latest Ruby version"
        return 0
    fi

    log_info "Installing Ruby $latest_ruby (this may take a few minutes)..."
    if rbenv install "$latest_ruby" && rbenv global "$latest_ruby"; then
        log_success "Ruby $latest_ruby installed and set as global default"

        log_info "Installing bundler gem..."
        gem install bundler && rbenv rehash
        log_success "bundler installed"

        log_info "Verified: $(rbenv version)"
    else
        log_warning "Failed to install Ruby version"
    fi
}

# Phase 5d: nvm (Node.js version manager)
phase_nvm() {
    log_info "Setting up nvm (Node.js version manager)..."

    local nvm_dir="$HOME/.nvm"

    # Check if nvm is properly installed (has nvm.sh script)
    if [[ -d "$nvm_dir" ]] && [[ -f "$nvm_dir/nvm.sh" ]]; then
        log_success "nvm is already installed"

        # Source nvm for this session
        export NVM_DIR="$nvm_dir"
        [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"

        # Check if any Node version is installed
        if nvm ls 2>/dev/null | grep -q 'v[0-9]'; then
            local current_version
            current_version=$(nvm current 2>/dev/null || echo "none")
            log_info "Node.js versions installed"
            log_success "Current global Node: $current_version"
        else
            log_warning "No Node.js versions installed via nvm"
            if [[ "$DRY_RUN" != "true" ]] && confirm "Install latest LTS Node.js?"; then
                log_info "Installing latest LTS Node.js..."
                if nvm install --lts && nvm alias default 'lts/*'; then
                    log_success "Node.js $(nvm current) installed and set as default"
                fi
            fi
        fi
        return 0
    fi

    # Remove incomplete installation if it exists
    if [[ -d "$nvm_dir" ]]; then
        log_warning "Found incomplete nvm installation, removing..."
        rm -rf "$nvm_dir"
    fi

    log_warning "nvm is not installed"

    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "Would install nvm from official installer"
        log_info "Would install latest LTS Node.js version"
        return 0
    fi

    if ! confirm "Install nvm (Node.js version manager)?"; then
        log_warning "Skipped nvm installation"
        return 0
    fi

    log_info "Installing nvm via official installer..."
    if curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.3/install.sh | bash; then
        log_success "nvm installed to $nvm_dir"
    else
        log_error "Failed to install nvm"
        return 1
    fi

    # Source nvm for this session
    export NVM_DIR="$nvm_dir"
    [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"

    log_info "Installing latest LTS Node.js version..."
    if nvm install --lts && nvm alias default 'lts/*'; then
        local node_version
        node_version=$(nvm current)
        log_success "Node.js $node_version installed and set as default"
        node --version 2>/dev/null && log_info "Verified: node $(node --version)"
        npm --version 2>/dev/null && log_info "Verified: npm $(npm --version)"
    else
        log_warning "Failed to install Node.js LTS version"
    fi
}

# Phase 6: Prezto and Powerlevel10k setup
phase_prezto() {
    log_phase "Phase 6: Prezto & Powerlevel10k Setup"

    local prezto_dir="$HOME/.zprezto"
    local p10k_module="$prezto_dir/modules/prompt/external/powerlevel10k"

    # Check if Prezto is installed
    if [[ -d "$prezto_dir" ]]; then
        log_success "Prezto is already installed"
    else
        log_warning "Prezto is not installed"

        if [[ "$DRY_RUN" == "true" ]]; then
            log_info "Would clone Prezto to $prezto_dir"
        else
            if confirm "Install Prezto (zsh framework)?"; then
                log_info "Cloning Prezto..."
                if git clone --recursive https://github.com/sorin-ionescu/prezto.git "$prezto_dir"; then
                    log_success "Prezto installed"
                else
                    log_error "Failed to clone Prezto"
                    exit 1
                fi
            else
                log_warning "Skipped Prezto installation - shell features will be limited"
            fi
        fi
    fi

    # Check if Powerlevel10k is installed
    if [[ -d "$prezto_dir" ]]; then
        if [[ -d "$p10k_module" ]]; then
            log_success "Powerlevel10k theme is installed"
        else
            log_warning "Powerlevel10k theme is not installed"

            if [[ "$DRY_RUN" == "true" ]]; then
                log_info "Would clone Powerlevel10k to $p10k_module"
            else
                if confirm "Install Powerlevel10k theme?"; then
                    log_info "Cloning Powerlevel10k..."
                    mkdir -p "$(dirname "$p10k_module")"
                    if git clone --depth=1 https://github.com/romkatv/powerlevel10k.git "$p10k_module"; then
                        log_success "Powerlevel10k installed"
                    else
                        log_error "Failed to clone Powerlevel10k"
                        exit 1
                    fi
                else
                    log_warning "Skipped Powerlevel10k installation - prompt will use default theme"
                fi
            fi
        fi
    fi

    # Create Prezto runcom symlinks (for files not managed by our dotfiles)
    if [[ -d "$prezto_dir" ]]; then
        log_info "Creating Prezto runcom symlinks..."

        # Only create symlinks for runcoms NOT managed by our dotfiles
        # Our dotfiles manage: .zshenv, .zshrc, .zprofile, .zpreztorc
        # Prezto provides: .zlogin, .zlogout
        local -a prezto_runcoms=("zlogin" "zlogout")

        for runcom in "${prezto_runcoms[@]}"; do
            local source_file="$prezto_dir/runcoms/$runcom"
            local target_file="$HOME/.$runcom"

            if [[ -f "$source_file" ]]; then
                if [[ -L "$target_file" ]] && [[ "$(readlink "$target_file")" == "$source_file" ]]; then
                    log_verbose "Already linked: ~/.$runcom"
                elif [[ "$DRY_RUN" == "true" ]]; then
                    log_info "Would create: ~/.$runcom -> $source_file"
                else
                    ln -sf "$source_file" "$target_file"
                    log_success "Created: ~/.$runcom -> $source_file"
                fi
            fi
        done
    fi
}

# Phase 7: Symlink creation
phase_symlinks() {
    if [[ "$SKIP_LINKS" == "true" ]]; then
        log_info "Skipping symlink creation (--skip-links flag)"
        return 0
    fi

    log_phase "Phase 7: Symlink Creation"

    local linker="$DOTFILES_ROOT/bin/core/link-dotfiles.py"

    if [[ ! -f "$linker" ]]; then
        log_error "link-dotfiles.py script not found: $linker"
        exit 2
    fi

    local link_args=()
    if [[ "$DRY_RUN" == "true" ]]; then
        link_args+=("--dry-run")
    else
        link_args+=("--apply")
    fi
    if [[ "$YES" == "true" ]]; then
        link_args+=("--yes")
    fi
    if [[ "$VERBOSE" == "true" ]]; then
        link_args+=("--verbose")
    fi

    log_info "Running link-dotfiles..."
    if python3 "$linker" "${link_args[@]}"; then
        log_success "Symlinks created successfully"
    else
        log_error "Symlink creation failed"
        exit 1
    fi
}

# Phase 7-alt: Scripts-only linking
phase_scripts_only() {
    log_phase "Phase 7: Scripts Linking (~/local/bin only)"

    local target_dir="$HOME/local/bin"

    # Ensure target directory exists
    if [[ ! -d "$target_dir" ]]; then
        if [[ "$DRY_RUN" == "true" ]]; then
            log_info "Would create directory: $target_dir"
        else
            mkdir -p "$target_dir"
            log_success "Created directory: $target_dir"
        fi
    fi

    local bin_dirs=("core" "credentials" "git" "ide" "macos")
    local linked_count=0
    local skipped_count=0
    local error_count=0

    for dir in "${bin_dirs[@]}"; do
        local source_dir="$DOTFILES_ROOT/bin/$dir"

        # Skip if directory doesn't exist
        if [[ ! -d "$source_dir" ]]; then
            log_verbose "Skipping $dir (directory not found)"
            continue
        fi

        # Skip macos on non-darwin platforms
        if [[ "$dir" == "macos" ]] && [[ "$PLATFORM" != "darwin" ]]; then
            log_verbose "Skipping $dir (not on macOS)"
            continue
        fi

        log_info "Processing bin/$dir/..."

        # Link each file in the directory
        for source_file in "$source_dir"/*; do
            # Skip if not a file
            if [[ ! -f "$source_file" ]]; then
                continue
            fi

            # Skip subdirectories like home_sync/, lib/, git-hooks/
            if [[ -d "$source_file" ]]; then
                continue
            fi

            local filename=$(basename "$source_file")
            local target_file="$target_dir/$filename"

            # Check if already linked correctly
            if [[ -L "$target_file" ]] && [[ "$(readlink "$target_file")" == "$source_file" ]]; then
                log_verbose "Already linked: $filename"
                ((skipped_count++)) || true
                continue
            fi

            # Create or update symlink
            if [[ "$DRY_RUN" == "true" ]]; then
                log_info "Would link: $filename -> bin/$dir/$filename"
                ((linked_count++)) || true
            else
                if ln -sf "$source_file" "$target_file"; then
                    # Make executable
                    chmod +x "$target_file" 2>/dev/null || true
                    log_success "Linked: $filename"
                    ((linked_count++)) || true
                else
                    log_error "Failed to link: $filename"
                    ((error_count++)) || true
                fi
            fi
        done
    done

    # Also link lib directories
    local lib_dirs=("bin/lib" "bin/git/lib")
    for lib_dir in "${lib_dirs[@]}"; do
        local source_lib="$DOTFILES_ROOT/$lib_dir"
        if [[ -d "$source_lib" ]]; then
            local target_lib="$target_dir/$(basename $(dirname "$lib_dir"))/lib"
            local target_parent=$(dirname "$target_lib")

            if [[ ! -d "$target_parent" ]]; then
                if [[ "$DRY_RUN" != "true" ]]; then
                    mkdir -p "$target_parent"
                fi
            fi

            if [[ -L "$target_lib" ]] && [[ "$(readlink "$target_lib")" == "$source_lib" ]]; then
                log_verbose "Already linked: $(basename $(dirname "$lib_dir"))/lib/"
                ((skipped_count++)) || true
            elif [[ "$DRY_RUN" == "true" ]]; then
                log_info "Would link: $(basename $(dirname "$lib_dir"))/lib/ -> $lib_dir/"
                ((linked_count++)) || true
            else
                if ln -sf "$source_lib" "$target_lib"; then
                    log_success "Linked: $(basename $(dirname "$lib_dir"))/lib/"
                    ((linked_count++)) || true
                else
                    log_error "Failed to link: $(basename $(dirname "$lib_dir"))/lib/"
                    ((error_count++)) || true
                fi
            fi
        fi
    done

    # Summary
    echo ""
    log_success "Linked: $linked_count scripts/libraries"
    log_info "Skipped: $skipped_count (already linked)"
    if [[ $error_count -gt 0 ]]; then
        log_error "Errors: $error_count"
        return 1
    fi

    # Fix permissions and ownership for all files in ~/local
    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "Would set executable permissions on all scripts in ~/local/bin"
        log_info "Would set ownership to $(whoami) for ~/local"
    else
        log_info "Setting executable permissions on scripts..."
        find "$target_dir" -type f -exec chmod +x {} \; 2>/dev/null || true

        log_info "Setting ownership to $(whoami) for ~/local..."
        chown -R "$(whoami)" "$HOME/local" 2>/dev/null || true

        log_success "Permissions and ownership updated"
    fi
}

# Phase 8: Shell configuration
phase_shell() {
    log_phase "Phase 8: Shell Configuration"

    local current_shell="${SHELL##*/}"
    log_info "Current shell: $current_shell"

    # Check for .hushlogin to suppress login messages
    if [[ -f "$HOME/.hushlogin" ]]; then
        log_info ".hushlogin exists - login messages suppressed"
    else
        log_info ".hushlogin not found - login messages will be shown"
        if [[ "$DRY_RUN" != "true" ]]; then
            if confirm "Create .hushlogin to suppress login messages?"; then
                touch "$HOME/.hushlogin"
                log_success "Created ~/.hushlogin"
            else
                log_info "Skipped .hushlogin creation"
            fi
        else
            log_info "Would prompt to create ~/.hushlogin"
        fi
    fi

    case "$current_shell" in
        zsh)
            if [[ -L "$HOME/.config/zsh/.zshrc" ]]; then
                log_success "~/.config/zsh/.zshrc is linked"
            else
                log_warning "~/.config/zsh/.zshrc is not linked"
            fi
            ;;
        bash)
            if [[ -L "$HOME/.bashrc" ]]; then
                log_success "~/.bashrc is linked"
            else
                log_info "~/.bashrc not managed by these dotfiles"
            fi
            ;;
        fish)
            log_info "Fish shell detected"
            ;;
        *)
            log_info "Detected shell: $current_shell"
            ;;
    esac
}

# Phase 9: Performance optimization (zsh)
phase_performance() {
    local current_shell="${SHELL##*/}"

    if [[ "$current_shell" != "zsh" ]]; then
        log_info "Skipping performance optimization (not using zsh)"
        return 0
    fi

    log_phase "Phase 9: Performance Optimization"

    local compile_script="$DOTFILES_ROOT/bin/core/zsh-compile"

    if [[ ! -f "$compile_script" ]]; then
        log_info "zsh-compile not found, skipping compilation"
        return 0
    fi

    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "Would compile zsh configuration files"
        return 0
    fi

    log_info "Compiling zsh configs for faster startup..."

    # Make executable if needed
    chmod +x "$compile_script" 2>/dev/null || true

    # Run compilation
    if command_exists zsh && zsh "$compile_script" &>/dev/null; then
        log_success "Zsh configs compiled to bytecode (.zwc)"
        log_info "Expected startup improvement: 100-200ms"
    else
        log_warning "Could not compile zsh configs (non-critical)"
    fi

    # Show performance info
    echo ""
    log_info "Performance features enabled:"
    echo "  - Lazy loading via Prezto: nvm (node module with --no-use)"
    echo "  - Lazy loading via lazy-load.zsh: pyenv, rbenv, mise, sdkman"
    echo "  - Compiled bytecode configs (.zwc files)"
    echo "  - Smart completion caching (24-hour refresh)"
    echo "  - Optimized history (10k entries)"
    echo ""
    log_info "To benchmark: zsh-benchmark"
}

# Show summary
show_summary() {
    log_phase "Installation Complete!"

    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "This was a dry run - no changes were made"
        log_info "Run './install' (without --dry-run) to actually install"
        return
    fi

    echo "Next Steps:"
    echo "  1. Restart your terminal or run: exec ${SHELL##*/}"
    echo "  2. Check environment: work-mode status"
    echo "  3. Verify git config: git config --list"
    echo ""

    # Show version manager verification commands
    echo "Verify Version Managers:"
    echo "  - pyenv: pyenv versions"
    echo "  - rbenv: rbenv versions"
    echo "  - nvm: nvm list"
    echo "  - mise: mise list (if installed)"
    echo ""

    echo "Verify Paths (after shell restart):"
    echo "  - which python  # Should point to ~/.pyenv/shims/python"
    echo "  - which ruby    # Should point to ~/.rbenv/shims/ruby"
    echo "  - which node    # Should point to ~/.nvm/versions/node/..."
    echo ""

    # Zsh-specific tips
    if [[ "${SHELL##*/}" == "zsh" ]]; then
        echo ""
        echo "Zsh Performance Tips:"
        echo "  - Benchmark startup: zsh-benchmark"
        echo "  - After config changes: zsh-compile && exec zsh"
        echo "  - Trim history: zsh-trim-history"
        echo "  - Target: < 500ms startup time"
        echo ""
        echo "Lazy Loading Info:"
        echo "  - Version managers load on first use (pyenv, rbenv, nvm, mise)"
        echo "  - First 'python', 'ruby', 'node' command may have ~100ms delay"
        echo "  - Subsequent commands are instant"
    fi

    echo ""
    echo "For help: ./install --help"
}

# Main execution
main() {
    parse_args "$@"

    # Show banner
    echo "================================================="
    echo " Dotfiles Installation"
    echo "================================================="
    echo ""

    if [[ "$DRY_RUN" == "true" ]]; then
        log_warning "DRY RUN MODE - No changes will be made"
        echo ""
    fi

    # Trap errors
    trap 'log_error "Installation failed"; exit 1' ERR

    # Execute phases
    if [[ "$SCRIPTS_ONLY" == "true" ]]; then
        # Scripts-only mode: skip everything except scripts linking
        log_info "Scripts-only mode: skipping full installation"
        phase_preflight
        phase_scripts_only
        log_phase "Scripts Update Complete!"
        log_info "Scripts in ~/local/bin have been updated"
        log_info "Run './install' without --scripts-only for full installation"
    else
        # Full installation
        phase_preflight
        phase_homebrew
        phase_dependencies
        phase_bundle
        phase_migrate_local_directory
        phase_version_managers
        phase_prezto
        phase_symlinks
        phase_shell
        phase_performance
        show_summary
    fi

    exit 0
}

main "$@"
