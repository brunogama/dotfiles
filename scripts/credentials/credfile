#!/usr/bin/env bash

# CredFile v2 - Enhanced file storage for CredMatch
# Stores filename and file content as separate base64 encoded parts

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Configuration
FILE_SEPARATOR="|||CREDFILE_SEPARATOR|||"  # Separator between filename and content
FILE_PREFIX="FILE_"                        # Prefix for file credentials

# Function to display usage
usage() {
    cat << EOF
CredFile v2 - Enhanced File Storage for CredMatch

Usage: $0 [COMMAND] [OPTIONS]

COMMANDS:
    put <key> <file>        Store a file in CredMatch
    get <key> [output]      Retrieve a file from CredMatch
    list                    List all stored files
    info <key>              Show file information
    rm <key>                Remove a stored file
    help                    Show this help

EXAMPLES:
    $0 put "ssh_config" ~/.ssh/config
    $0 get "ssh_config" ~/.ssh/config.backup
    $0 get "ssh_config"                    # Output to stdout
    $0 list
    $0 info "ssh_config"
    $0 rm "ssh_config"

STORAGE FORMAT:
    Each file is stored as: [base64(filename)]$FILE_SEPARATOR[base64(file_content)]
    This allows preserving original filenames and handling any file type.

EOF
}

# Function to log messages
log() {
    local level="$1"
    shift
    case "$level" in
        "INFO")  echo -e "${BLUE}[INFO]${NC} $*" >&2 ;;
        "SUCCESS") echo -e "${GREEN}[SUCCESS]${NC} $*" >&2 ;;
        "WARN")  echo -e "${YELLOW}[WARN]${NC} $*" >&2 ;;
        "ERROR") echo -e "${RED}[ERROR]${NC} $*" >&2 ;;
    esac
}

# Function to get master password
get_master_password() {
    if ! command -v get-api-key &> /dev/null; then
        log "ERROR" "get-api-key command not found"
        return 1
    fi
    
    local password=$(get-api-key "CREDMATCH_MASTER_PASSWORD" 2>/dev/null || echo "")
    if [[ -z "$password" ]]; then
        log "ERROR" "Master password not found in Keychain"
        log "INFO" "Store it with: store-api-key 'CREDMATCH_MASTER_PASSWORD' 'your-password'"
        return 1
    fi
    
    echo "$password"
}

# Function to check dependencies
check_dependencies() {
    local missing_deps=()
    
    for cmd in credmatch base64; do
        if ! command -v "$cmd" &> /dev/null; then
            missing_deps+=("$cmd")
        fi
    done
    
    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        log "ERROR" "Missing dependencies: ${missing_deps[*]}"
        return 1
    fi
    
    return 0
}

# Function to encode filename
encode_filename() {
    local filepath="$1"
    local filename=$(basename "$filepath")
    echo -n "$filename" | base64
}

# Function to decode filename
decode_filename() {
    local encoded_filename="$1"
    echo "$encoded_filename" | base64 -d
}

# Function to encode file content
encode_file_content() {
    local filepath="$1"
    base64 -i "$filepath"
}

# Function to decode file content
decode_file_content() {
    local encoded_content="$1"
    echo "$encoded_content" | base64 -d
}

# Function to create storage format
create_storage_format() {
    local filepath="$1"
    local encoded_filename=$(encode_filename "$filepath")
    local encoded_content=$(encode_file_content "$filepath")
    
    echo "${encoded_filename}${FILE_SEPARATOR}${encoded_content}"
}

# Function to parse storage format
parse_storage_format() {
    local stored_data="$1"
    
    if [[ "$stored_data" == *"$FILE_SEPARATOR"* ]]; then
        local encoded_filename="${stored_data%%$FILE_SEPARATOR*}"
        local encoded_content="${stored_data#*$FILE_SEPARATOR}"
        
        echo "FILENAME:$encoded_filename"
        echo "CONTENT:$encoded_content"
        return 0
    else
        log "ERROR" "Invalid storage format (missing separator)"
        return 1
    fi
}

# Function to store a file
put_file() {
    local key="$1"
    local file_path="$2"
    
    if [[ ! -f "$file_path" ]]; then
        log "ERROR" "File not found: $file_path"
        return 1
    fi
    
    local master_password
    if ! master_password=$(get_master_password); then
        return 1
    fi
    
    local full_key="${FILE_PREFIX}${key}"
    local file_size=$(stat -f%z "$file_path" 2>/dev/null || stat -c%s "$file_path" 2>/dev/null)
    local filename=$(basename "$file_path")
    
    log "INFO" "Storing file: $filename ($file_size bytes) as '$key'"
    
    # Create storage format
    local storage_data
    if storage_data=$(create_storage_format "$file_path"); then
        if credmatch store "$master_password" "$full_key" "$storage_data" &>/dev/null; then
            log "SUCCESS" "File '$filename' stored as '$key'"
            log "INFO" "Original path: $file_path"
            log "INFO" "Size: $file_size bytes"
        else
            log "ERROR" "Failed to store file in CredMatch"
            return 1
        fi
    else
        log "ERROR" "Failed to create storage format"
        return 1
    fi
}

# Function to retrieve a file
get_file() {
    local key="$1"
    local output_path="${2:-}"
    
    local master_password
    if ! master_password=$(get_master_password); then
        return 1
    fi
    
    local full_key="${FILE_PREFIX}${key}"
    
    # Retrieve from CredMatch
    local stored_data
    if stored_data=$(credmatch fetch "$master_password" "$full_key" 2>/dev/null); then
        # Parse storage format
        local parse_result
        if parse_result=$(parse_storage_format "$stored_data"); then
            local encoded_filename=$(echo "$parse_result" | grep "^FILENAME:" | cut -d: -f2-)
            local encoded_content=$(echo "$parse_result" | grep "^CONTENT:" | cut -d: -f2-)
            
            local original_filename=$(decode_filename "$encoded_filename")
            
            if [[ -n "$output_path" ]]; then
                # Save to specified path
                if decode_file_content "$encoded_content" > "$output_path"; then
                    local saved_size=$(stat -f%z "$output_path" 2>/dev/null || stat -c%s "$output_path" 2>/dev/null)
                    log "SUCCESS" "File retrieved: $output_path"
                    log "INFO" "Original filename: $original_filename"
                    log "INFO" "Size: $saved_size bytes"
                else
                    log "ERROR" "Failed to decode and save file"
                    return 1
                fi
            else
                # Output to stdout (no logging to avoid mixing with content)
                decode_file_content "$encoded_content"
            fi
        else
            log "ERROR" "Failed to parse stored file format"
            return 1
        fi
    else
        log "ERROR" "File '$key' not found in CredMatch"
        return 1
    fi
}

# Function to list stored files
list_files() {
    local master_password
    if ! master_password=$(get_master_password); then
        return 1
    fi
    
    log "INFO" "Listing stored files..."
    
    local all_creds
    if all_creds=$(credmatch list "$master_password" 2>/dev/null); then
        echo -e "${BLUE}📁 Stored Files:${NC}"
        
        local file_count=0
        
        # Process all credentials and look for FILE_ entries (strip ANSI colors first)
        echo "$all_creds" | sed 's/\x1b\[[0-9;]*m//g' | grep "=" | while IFS='=' read -r key value; do
            if [[ "$key" =~ ^FILE_(.+)$ ]]; then
                local file_key="${BASH_REMATCH[1]}"
                
                # Try to parse the storage format to get filename
                local parse_result
                if parse_result=$(parse_storage_format "$value" 2>/dev/null); then
                    local encoded_filename=$(echo "$parse_result" | grep "^FILENAME:" | cut -d: -f2-)
                    local encoded_content=$(echo "$parse_result" | grep "^CONTENT:" | cut -d: -f2-)
                    
                    local original_filename=$(decode_filename "$encoded_filename" 2>/dev/null || echo "unknown")
                    local encoded_size=${#encoded_content}
                    local approx_size=$(( encoded_size * 3 / 4 ))
                    
                    echo -e "  ${GREEN}✓${NC} $file_key"
                    echo -e "    Original: $original_filename"
                    echo -e "    Size: ≈$approx_size bytes"
                else
                    # Legacy format or corrupted
                    local total_size=${#value}
                    local approx_size=$(( total_size * 3 / 4 ))
                    echo -e "  ${YELLOW}⚠${NC} $file_key (legacy format)"
                    echo -e "    Size: ≈$approx_size bytes"
                fi
                echo ""
            fi
        done
        
        # Count files for summary (strip ANSI color codes first)
        local file_count=$(echo "$all_creds" | sed 's/\x1b\[[0-9;]*m//g' | grep "=" | grep "^FILE_" | wc -l | tr -d ' ')
        
        if [[ $file_count -eq 0 ]]; then
            echo -e "${YELLOW}  No files found${NC}"
            echo -e "${BLUE}  Store a file with: $0 put <key> <file>${NC}"
        else
            echo -e "${GREEN}Total: $file_count files${NC}"
        fi
    else
        log "ERROR" "Failed to list credentials from CredMatch"
        return 1
    fi
}

# Function to show file info
info_file() {
    local key="$1"
    
    local master_password
    if ! master_password=$(get_master_password); then
        return 1
    fi
    
    local full_key="${FILE_PREFIX}${key}"
    
    local stored_data
    if stored_data=$(credmatch fetch "$master_password" "$full_key" 2>/dev/null); then
        echo -e "${BLUE}📄 File Info: $key${NC}"
        echo -e "  ${GREEN}CredMatch Key:${NC} $full_key"
        
        # Try to parse the storage format
        local parse_result
        if parse_result=$(parse_storage_format "$stored_data" 2>/dev/null); then
            local encoded_filename=$(echo "$parse_result" | grep "^FILENAME:" | cut -d: -f2-)
            local encoded_content=$(echo "$parse_result" | grep "^CONTENT:" | cut -d: -f2-)
            
            local original_filename=$(decode_filename "$encoded_filename" 2>/dev/null || echo "unknown")
            local filename_size=${#encoded_filename}
            local content_size=${#encoded_content}
            local total_size=${#stored_data}
            local approx_original_size=$(( content_size * 3 / 4 ))
            
            echo -e "  ${GREEN}Original Filename:${NC} $original_filename"
            echo -e "  ${GREEN}Approx Original Size:${NC} $approx_original_size bytes"
            echo -e "  ${GREEN}Encoded Filename Size:${NC} $filename_size bytes"
            echo -e "  ${GREEN}Encoded Content Size:${NC} $content_size bytes"
            echo -e "  ${GREEN}Total Stored Size:${NC} $total_size bytes"
            echo -e "  ${GREEN}Storage Format:${NC} v2 (filename + separator + content)"
        else
            # Legacy format
            local total_size=${#stored_data}
            local approx_size=$(( total_size * 3 / 4 ))
            echo -e "  ${YELLOW}Storage Format:${NC} legacy (content only)"
            echo -e "  ${GREEN}Encoded Size:${NC} $total_size bytes"
            echo -e "  ${GREEN}Approx Original Size:${NC} $approx_size bytes"
        fi
        
        echo -e "\n${BLUE}Commands:${NC}"
        echo -e "  Get: $0 get '$key' [output_file]"
        echo -e "  Remove: $0 rm '$key'"
    else
        log "ERROR" "File '$key' not found"
        return 1
    fi
}

# Function to remove a file
remove_file() {
    local key="$1"
    
    local master_password
    if ! master_password=$(get_master_password); then
        return 1
    fi
    
    local full_key="${FILE_PREFIX}${key}"
    
    if credmatch fetch "$master_password" "$full_key" &>/dev/null; then
        # Store empty content to effectively delete
        if credmatch store "$master_password" "$full_key" "" &>/dev/null; then
            log "SUCCESS" "File '$key' removed"
        else
            log "ERROR" "Failed to remove file"
            return 1
        fi
    else
        log "ERROR" "File '$key' not found"
        return 1
    fi
}

# Function to migrate from v1 format
migrate_file() {
    local key="$1"
    local original_filename="$2"
    
    local master_password
    if ! master_password=$(get_master_password); then
        return 1
    fi
    
    local full_key="${FILE_PREFIX}${key}"
    
    log "INFO" "Migrating file '$key' to v2 format..."
    
    # Get current content (should be just base64 encoded file)
    local old_content
    if old_content=$(credmatch fetch "$master_password" "$full_key" 2>/dev/null); then
        # Create new format with provided filename
        local encoded_filename=$(echo -n "$original_filename" | base64)
        local new_content="${encoded_filename}${FILE_SEPARATOR}${old_content}"
        
        if credmatch store "$master_password" "$full_key" "$new_content" &>/dev/null; then
            log "SUCCESS" "File '$key' migrated to v2 format"
        else
            log "ERROR" "Failed to migrate file"
            return 1
        fi
    else
        log "ERROR" "File '$key' not found"
        return 1
    fi
}

# Main function
main() {
    local command="${1:-help}"
    
    # Check dependencies
    if ! check_dependencies; then
        exit 1
    fi
    
    case "$command" in
        "put")
            if [[ $# -lt 3 ]]; then
                log "ERROR" "Usage: $0 put <key> <file>"
                exit 1
            fi
            put_file "$2" "$3"
            ;;
        "get")
            if [[ $# -lt 2 ]]; then
                log "ERROR" "Usage: $0 get <key> [output_file]"
                exit 1
            fi
            get_file "$2" "${3:-}"
            ;;
        "list"|"ls")
            list_files
            ;;
        "info")
            if [[ $# -lt 2 ]]; then
                log "ERROR" "Usage: $0 info <key>"
                exit 1
            fi
            info_file "$2"
            ;;
        "rm"|"remove"|"delete")
            if [[ $# -lt 2 ]]; then
                log "ERROR" "Usage: $0 rm <key>"
                exit 1
            fi
            remove_file "$2"
            ;;
        "migrate")
            if [[ $# -lt 3 ]]; then
                log "ERROR" "Usage: $0 migrate <key> <original_filename>"
                log "INFO" "Migrate a v1 format file to v2 format"
                exit 1
            fi
            migrate_file "$2" "$3"
            ;;
        "help"|*)
            usage
            ;;
    esac
}

# Run main function
main "$@"
